---
layout: post
title: 函数工作原理
categories: Assembly-Programming
---


> 参考普林斯顿关于汇编中函数的[讲义](http://www.cs.princeton.edu/courses/archive/spr11/cos217/lectures/15AssemblyFunctions.pdf)，请一定抽空认真阅读一下该讲义！！！相信理解了函数的工作原理，对我们学习其他语言都有帮助。

## 统一概念

首先我们来统一概念，如果再 A 函数中调用了 B 函数，那么我们称 A 是 caller，B 是 callee。这么做的目的是为了节省篇幅。如在 `C++` 的 `main()` 函数中，我们使用的 `sort()` 函数，`main()` 是 caller，`sort()` 是 callee。

本文会谈到很多问题，但是只会提及最终解决方案，在普林斯顿讲义中同一个问题都会尝试多种解决方案，然后发现一些方法的局限性，这一过程阐述清楚了为什么选择这种方案最为最终方案，很有启迪意义。

## 调用和返回

在这一节中我们要解决两个疑问

+ caller 如何跳转到 callee
+ callee 如何跳转回 caller

### caller 如何跳转到 callee

在汇编语言中，变量名变量起始地址的助记符号，同样的，函数名也是函数起始地址的助记符号，我们可以把这些符号统称为 label

```nasm
call functionName	;call 指令调用函数
ret		;函数定义块最后的 ret 命令返回 caller 中下一条指令地址
```

这一条语句是汇编语言调用名为 `functionName` 的函数。解决函数跳转问题需要依靠**栈**（stack）来解决，这一方法可以解决许多函数嵌套调用的时候返回地址的保存问题。

![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm6.png)



### callee 如何跳转回 caller

caller 将其下一条指令地址（EIP） 压入栈，callee 在最后 `ret` 将栈顶的指令地址出栈， caller继续执行。

![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm7.png)

跟踪栈中的状态

![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm8.png)



## 传递参数

这一节的核心问题：

+ caller 是如何向 callee 传递参数的

例如在 C 语言中

```c
int add(int a, int b, int c) {
  int d;
  d = a + b + c;
  return d; 
}

int f(void) {
  return add(3, 4, 5);
}
```

当我们调用函数时需要向函数传递参数。那么在汇编中是如何实现的呢？还是依靠栈来实现！caller（注意是caller）在`call functionName` 之前将他要传递给 callee 的参数压**从右至左**（C 语言应该讲到过）入栈，然后执行 `call` 命令，在 callee `ret` 之后，再从栈上删除参数。

```nasm
f:
	...
	;参数压入栈，dword 用来限定传递参数长度是双字 4-byte
	push dword param1
	push dowrd param2
	push dowrd param3
	call add
	; 参数出栈，因为每个参数都是用 4-byte 储存的，所以需要 3*4-byte
	;又因为内存中栈的增长方向是由低到高，所以是 esp += 12
	add esp, 12 	

add:
	...
;  利用 ESP 的偏移地址索引参数。 
	mov whereve, [esp+4]		
	mov whereve, [esp+8]
	mov whereve, [esp+12]
	...
	ret
```



![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm9.png)

但是这样就出现一个问题，如果 callee 需要栈做其他事情，讲其他数据压入栈，那么 ESP 就会丢失参数的位置。解决的方法是，利用 EBP 来用偏移量索引参数解放 ESP。改动 `add` 代码

```nasm
add:
	push ebp	;函数开始先把 EBP 压入栈
	mov esp, ebp	;更新 ESP
	...
	#  利用 ESP 的偏移地址索引参数
	mov whereve, [ebp+8]
	mov whereve, [esp+12]
	mov whereve, [esp+16]
	...
	pop ebp		;函数结束将 EBP 推出栈
	ret
```



![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm10.png)

现在应该就能理解 ESP 和 EBP 的区别了吧。

## 储存局部变量

这一节的核心问题：

+ callee 是如何储存局部变量的

```c
int add(int a, int b, int c) {
  int d;		//局部变量
  d = a + b + c;
  return d; 
}
int foo(void) {
  return add(3, 4, 5);
}
```

还是用栈来解决！利用上文讲到的 EBP

```nasm
	mov whatever, [ebp-4]	;局部变量存放在低地址
```

![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm11.png)



## 处理寄存器问题

这一节核心问题：

+ 寄存器是有限资源，如果 caller 和 callee 使用相同的寄存器怎么办？

还是用栈！

解决方法是：

1. 把之前寄存器中的内容储存在栈上
2. 之后在某一时间再从栈中加载到栈

在需要的时候：

+ Caller 保存 EAX，EDX，ECX等寄存器，有必要的话
  + caller 在 `call` 之前保存到栈
  + `call ` 之后从栈中取出重新保存
+ Callee 保存 EBX，ESI，EDI等寄存器，有必要的话
  + callee 一开始的就保存到栈上
  + `ret` 之前重新储存

![](https://raw.githubusercontent.com/hychn/hychn.github.io/master/img/asm12.png)

## 返回值

这一节核心问题：

+ calle 是如何将函数值返回的

```c
int add3(int a, int b, int c) {
  int d;
  d = a + b + c;
  return d;
}
int foo(void) {
  return add3(3, 4, 5);
}
```

#### 储存到 Stack Frame

对于每一个调用的函数在栈上都有一个 **Stack Frame**（不知道怎么翻译），ESP 指向当前 stack frame 的低地址（顶），EBP 指向当前 stack frame 高地址。在 stack frame 中包含：

+ 返回地址（old EIP）
+ old EBP
+ 保存的寄存器的值
+ 局部变量
+ 传递给 callee 的参数

#### 储存到寄存器中

+ 对于整形或者指针：存储到 EAX 寄存器，如 `char`，`short`，`int`，`long`，`pointer`
  + 对于浮点型：储存到浮点型寄存器（超出范围）
  + 结构体：存储到堆栈上（超出范围）



