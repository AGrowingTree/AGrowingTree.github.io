<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Young</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2016-12-03T14:03:51+08:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Huayang Li</name>
   <email>waajoenglei@gmail.com</email>
 </author>

 
 <entry>
   <title>Unix/Linux 文件和进程管理</title>
   <link href="http://localhost:4000/2016/05/23/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
   <updated>2016-05-23T00:00:00+08:00</updated>
   <id>http://localhost:4000/2016/05/23/Linux学习笔记</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#vim&quot;&gt;Vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86&quot;&gt;文件管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#chmod-%E5%91%BD%E4%BB%A4&quot;&gt;chmod 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chown%E5%92%8Cchgrp%E5%91%BD%E4%BB%A4&quot;&gt;chown和chgrp命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86&quot;&gt;进程管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7&quot;&gt;进程的属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%91%BD%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84&quot;&gt;命令是如何执行的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%83%B5%E5%B0%B8zombie%E8%BF%9B%E7%A8%8B&quot;&gt;僵尸(zombie)进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%A4%E7%AB%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%90%8E%E5%8F%B0%E9%A9%BB%E7%95%99%E8%BF%9B%E7%A8%8B&quot;&gt;孤立进程和后台驻留进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E5%8F%B0%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2&quot;&gt;前台后台进程之间的切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BF%A1%E5%8F%B7&quot;&gt;信号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;本文基于&lt;a href=&quot;https://www.tutorialspoint.com/unix/index.htm&quot;&gt;Learn Unix&lt;/a&gt;教程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;vim&quot;&gt;1. Vim&lt;/h2&gt;

&lt;p&gt;在开始主要内容之前，先来说一下Vim。Vim 是一款终端上的文本编辑器。我最初使用的是&lt;code&gt;Sublime Text&lt;/code&gt;，后来开始学习使用Vim，Vim的学习周期比较长，但是学习新东西上手最重要，上手以后觉得自己掌握的几个命令无法满足自己时自然会继续学习。对于初学者只需要掌握&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hjkl&lt;/code&gt;进行移动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;进入插入模式，&lt;code&gt;esc&lt;/code&gt;进入普通模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;粘贴，&lt;code&gt;v&lt;/code&gt;选中，&lt;code&gt;y&lt;/code&gt;复制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就可以开始Vim之旅了！&lt;/p&gt;

&lt;p&gt;最近一个叫Neovim的东西出现，可以阅读这篇&lt;a href=&quot;http://geoff.greer.fm/2015/01/15/why-neovim-is-better-than-vim/&quot;&gt;Why Neovim is Better than Vim&lt;/a&gt;，Neovim最明显的体验就是没有了Vim卡顿的状况，但是现在还不支持&lt;code&gt;Lua&lt;/code&gt;，无法使用&lt;code&gt;Neocomplete&lt;/code&gt;插件。同学写了一份不错的Neovim配置&lt;a href=&quot;https://github.com/neo1218/MuxiVim&quot;&gt;MuxiVim&lt;/a&gt;，包含了必要的插件，快捷键映射也十分方便，果断抛弃&lt;code&gt;spf13&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外推荐一份非常清丽脱俗的博文&lt;a href=&quot;http://benmccormick.org/2014/07/02/learning-vim-in-2014-vim-as-language/&quot;&gt;Vim as Language&lt;/a&gt;来讲解命令之间的组合。&lt;/p&gt;

&lt;h2 id=&quot;文件管理&quot;&gt;2. 文件管理&lt;/h2&gt;

&lt;p&gt;Linux中的文件有三类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通文件：保存数据，文本，程序指令的文件&lt;/li&gt;
&lt;li&gt;目录：目录文件包含了普通文件和特殊文件&lt;/li&gt;
&lt;li&gt;特殊文件：和硬件、调制解调器、适配器等交互的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/Hello
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ls -l
total 16
-rw-r--r--  1 Demon  staff   0 Dec  2 23:50 2.txt
lrwxr-xr-x  1 Demon  staff   5 Dec  2 23:56 3.txt -&amp;gt; 1.txt
drwxr-xr-x  2 Demon  staff  68 Dec  2 23:58 dir
-rwxrwxrwx  1 Demon  staff   0 Dec  3 00:26 hello.cpp
lrwxr-xr-x  1 Demon  staff   3 Dec  2 23:57 mydir -&amp;gt; dir
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每一列的意思分别为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一列：文件类型，之后是文件权限&lt;/li&gt;
&lt;li&gt;第二列：该文件或者目录所占的存储块&lt;/li&gt;
&lt;li&gt;第三列：文件的所有者(owner)&lt;/li&gt;
&lt;li&gt;第四列：所有者的组(group)。每一个Unix用户都有一个相关联的组&lt;/li&gt;
&lt;li&gt;第五列：表示有多少Bytes&lt;/li&gt;
&lt;li&gt;第六列：文件或目录创建或者最近修改时间&lt;/li&gt;
&lt;li&gt;第七列：文件或者目录名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到第一列有字符&lt;code&gt;d&lt;/code&gt;或者&lt;code&gt;-&lt;/code&gt;，这些字符表示文件的类型，&lt;code&gt;d&lt;/code&gt;表示目录，&lt;code&gt;-&lt;/code&gt;表示普通文件，还有其他的文件类型如下所示:&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;block device，这种叫法是因为硬件一次读或写一个扇区块。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;Character device，这种叫法是因为每一个字符都被单独处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;符号链接文件。符号链接(软链接)任何正规文件(regular file)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;Named pipe负责进程间通信，与pipe非常相似。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;Socket 负责进程间通信。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;关于文件前缀的更多详细信息请参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_file_types&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之后的&lt;code&gt;rwx&lt;/code&gt;分别为 (&lt;strong&gt;r&lt;/strong&gt;)ead, (&lt;strong&gt;w&lt;/strong&gt;)rite, e(&lt;strong&gt;x&lt;/strong&gt;)ecute，如果某项权限不存在，则显示为&lt;code&gt;-&lt;/code&gt;。每三个一组，按顺序分别对应用户(user)，用户组(group)，还有其他(other)。读写权限很好理解，对于文件来说就是读和写文件内容，对于目录来说就是查看和写入目录。对于执行权限:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通文件：编译过后生成的可执行文件如果想要执行，必须有执行权限。&lt;/li&gt;
&lt;li&gt;目录文件：&lt;code&gt;cd&lt;/code&gt;或者&lt;code&gt;ls&lt;/code&gt;等命令的执行需要目录有执行权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;chmod-命令&quot;&gt;chmod 命令&lt;/h3&gt;

&lt;p&gt;文件的权限可以与二进制数对应，方便利用&lt;code&gt;chmod&lt;/code&gt;命令修改&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;rwx rwx rwx = 111 111 111
rw- rw- rw- = 110 110 110
rwx --- --- = 111 000 000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;rwx = 111 in binary = 7
rw- = 110 in binary = 6
r-x = 101 in binary = 5
r-- = 100 in binary = 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面所展示的，文件2.txt的权限为&lt;code&gt;rw-r--r--&lt;/code&gt;, 我们将它修改为&lt;code&gt;rwxrwxrx&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;chmod 777 2.txt
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ls -l 2.txt
-rwxrwxrwx  1 Demon  staff  0 Dec  2 23:50 2.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;chown和chgrp命令&quot;&gt;chown和chgrp命令&lt;/h3&gt;

&lt;p&gt;如果需要改变文件所有者或者组需要用&lt;code&gt;sudo&lt;/code&gt;得到权限&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo chown new_owner some_file
Password:
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo chgrp new_group some_file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;进程管理&quot;&gt;3. 进程管理&lt;/h2&gt;

&lt;p&gt;一般情况下，需要等一个命令运行结束以后才能输入下一个命令(不讨论分屏和多窗口)，这些命令我们称为&lt;strong&gt;&lt;em&gt;前台进程&lt;/em&gt;&lt;/strong&gt; (Foreground Process)，之后会讲到&lt;strong&gt;&lt;em&gt;后台进程&lt;/em&gt;&lt;/strong&gt; (Background Process)。关于进程的概念，就不在这里太多讨论，不了解的同学可以参考&lt;a href=&quot;https://defrur.gitbooks.io/introduction-to-process/content/concept.html&quot;&gt;这里&lt;/a&gt;。关于UNIX进程，本文参考了这篇&lt;a href=&quot;http://www.brianstorti.com/an_introduction_to_unix_processes/&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;进程的属性&quot;&gt;3.1 进程的属性&lt;/h3&gt;

&lt;p&gt;查看正在运行的进程可以用&lt;code&gt;ps&lt;/code&gt;(process status)命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ps
  PID TTY           TIME CMD
30628 ttys000    0:00.08 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp Demon
30631 ttys000    0:00.49 -zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以用&lt;code&gt;-o&lt;/code&gt;参数来选择输出信息，例如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ps -o pid,ppid,tty,uid,args
  PID  PPID TTY        UID ARGS
30628  3054 ttys000    501 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp
30631 30629 ttys000    501 -zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;PID&lt;/strong&gt; 是进程的标志码，唯一确定。PID是随机分配的，某一个PID可能和某个已经结束的进程的PID一样，但是一定是在当前所有进程中唯一的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PPID&lt;/strong&gt; 是父进程的ID，不严格的来说，每一个进程都会有一个父进程，子进程由父进程创建&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TTY&lt;/strong&gt; 该属性是对终端会话(terminal session)的标识，也就是进程被触发的终端。几乎所有进程都会有TTY属性，出了后台驻留的程序。可以使用&lt;code&gt;screen&lt;/code&gt;命令来创建新的会话，来感受一下，screen的用法请参考&lt;a href=&quot;https://github.com/chenzhiwei/linux/tree/master/screen&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen -S hello &lt;span class=&quot;c&quot;&gt;#ctrl+a+d可以挂起会话&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;detached]
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ps 
  PID TTY           TIME CMD
30628 ttys000    0:00.08 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp Demon
30631 ttys000    0:00.52 -zsh
32379 ttys001    0:00.19 zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在看到多了一个&lt;code&gt;ttys001&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UID&lt;/strong&gt; 识别进程拥有者的用户ID，进程会根据UID这只权限。检查你的用户ID&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;id -u Demon
501
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ARGS&lt;/strong&gt; 是紧跟进程的参数&lt;/p&gt;

&lt;p&gt;更多的&lt;code&gt;ps&lt;/code&gt;属性可以查文档&lt;/p&gt;

&lt;h3 id=&quot;命令是如何执行的&quot;&gt;3.2 命令是如何执行的&lt;/h3&gt;

&lt;p&gt;进程的产生于两个命令有关&lt;code&gt;fork&lt;/code&gt;和&lt;code&gt;exec&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fork: 复制当前进程，是一个系统调用&lt;/li&gt;
&lt;li&gt;exec: 取代复制的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以vim 创建的过程为例，当在终端输入&lt;code&gt;vim&lt;/code&gt;命令的时候，背后的实际操作是，&lt;code&gt;bash&lt;/code&gt;(我的是zsh)调用&lt;code&gt;fork&lt;/code&gt;将它自己拷贝。然后&lt;code&gt;exec&lt;/code&gt;将这个拷贝替换成&lt;code&gt;vim&lt;/code&gt;程序。这个vim进程的PPID就是被拷贝的进程，PID就是&lt;code&gt;vim&lt;/code&gt;程序的进程ID，如下所示，另外我使用的是neovim，所以显示的是nvim而不是vim。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ps -o pid,ppid,tty,uid,args
    PID  PPID TTY        UID ARGS
30628  3054 ttys000    501 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server login -fp
30631 30629 ttys000    501 -zsh
32794 30631 ttys000    501 nvim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们直接执行，则&lt;code&gt;bash&lt;/code&gt;不进行拷贝&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;vim 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vim程序会直接替代&lt;code&gt;bash&lt;/code&gt;进程，当退出vim的时候，终端窗口也就一起关闭了。&lt;/p&gt;

&lt;h3 id=&quot;僵尸zombie进程&quot;&gt;3.3 僵尸(zombie)进程&lt;/h3&gt;

&lt;p&gt;每一个进程结束都会返回一个结束码(exit code)，成功的进程返回0，如果有错则返回其他，之后进程会根据这个结束码抛错&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;nop
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt;:cd:13: no such file or directory: nop
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父进程通过系统调用&lt;code&gt;wait&lt;/code&gt;读取该进程&lt;/p&gt;

&lt;p&gt;一个进程成为僵尸进程，当它已经结束，但是父进程并没有调用&lt;code&gt;wait&lt;/code&gt;，这个进程还可以用&lt;code&gt;ps&lt;/code&gt;查看到，但是状态变为&lt;code&gt;z&lt;/code&gt;。所以这个程序并没有真正的退出，一直到父进程调用&lt;code&gt;wait&lt;/code&gt;之后才真的结束。&lt;/p&gt;

&lt;h3 id=&quot;孤立进程和后台驻留进程&quot;&gt;3.4 孤立进程和后台驻留进程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;孤立进程&lt;/strong&gt;    当一个进程还在，但是父进程结束的时候，初始进程(系统执行的第一个进程，通常是&lt;code&gt;init&lt;/code&gt;，在Mac OS是&lt;code&gt;lanunchd&lt;/code&gt;进程)会成为它的父进程，这些孤立进程的PPID是1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后台驻留进程&lt;/strong&gt;  后台驻留进程在后台运行，并且不依附于控制终端。后台驻留程序的父进程是&lt;code&gt;init&lt;/code&gt;，并且名字大多以&lt;code&gt;d&lt;/code&gt;结尾，如&lt;code&gt;syslogd&lt;/code&gt;, &lt;code&gt;sshd&lt;/code&gt;, &lt;code&gt;httpd&lt;/code&gt;。后台驻留程序可以是&lt;code&gt;init&lt;/code&gt;生成的，也可以是某个进程有意的成为孤立进程。&lt;/p&gt;

&lt;h3 id=&quot;前台后台进程之间的切换&quot;&gt;3.5 前台后台进程之间的切换&lt;/h3&gt;

&lt;p&gt;如何让一个进程在后台运行呢？&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;brew update &amp;amp;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2] 33196
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要在进程的末尾添加&lt;code&gt;&amp;amp;&lt;/code&gt;符号。&lt;code&gt;brew&lt;/code&gt;是Mac Os中的命令，类似于Ubuntu 的&lt;code&gt;apt-get&lt;/code&gt;。如上所示 ,&lt;code&gt;[2] 33196&lt;/code&gt;，其中&lt;code&gt;2&lt;/code&gt;是进程的作业号，&lt;code&gt;33196&lt;/code&gt;是进程的PID。我们可以用&lt;code&gt;jobs&lt;/code&gt;命令查看作业信息：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;jobs&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]  + suspended &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tty output&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  nvim
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;2]    running    brew update
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果一个后台运行的进程需要输入的话，会自动转为&lt;code&gt;suspended&lt;/code&gt;状态并提醒用户，可以用&lt;code&gt;fg&lt;/code&gt;命令将其调到前台执行，完成输入以后如果想要再放到后台执行可以使用&lt;code&gt;Ctrl+z&lt;/code&gt;。&lt;code&gt;bg&lt;/code&gt;命令与&lt;code&gt;fg&lt;/code&gt;命令类似，但是是调到后台继续执行。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo ls -l &amp;amp;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 34113
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]  + 34113 suspended &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tty output&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  sudo ls -l
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;jobs&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]  + suspended &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;tty output&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  sudo ls -l
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;fg&lt;/span&gt; %1 &lt;span class=&quot;c&quot;&gt;#fg详情请查看文档&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]  + 34113 continued  sudo ls -l
Password:
total 16
-rwxrwxrwx  1 Demon  staff   0 Dec  2 23:50 2.txt
lrwxr-xr-x  1 Demon  staff   5 Dec  2 23:56 3.txt -&amp;gt; 1.txt
drwxr-xr-x  2 Demon  staff  68 Dec  2 23:58 dir
-rwxrwxrwx  1 Demon  staff   0 Dec  3 00:26 hello.cpp
lrwxr-xr-x  1 Demon  staff   3 Dec  2 23:57 mydir -&amp;gt; dir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，如果想让进程即使关闭了终端依旧执行可以使用&lt;code&gt;nohup&lt;/code&gt;命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;nohup find -size +100k &amp;gt; log.txt &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行命令 调用的find命令，查找超过100k的文件，并且将标准输出通过管道写到&lt;code&gt;log.txt&lt;/code&gt;文件，这个进程在后台执行，即使退出shell依旧执行。&lt;/p&gt;

&lt;h3 id=&quot;信号&quot;&gt;3.6 信号&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;kill&lt;/code&gt;命令可以再进程之间发送信号，&lt;code&gt;kill&lt;/code&gt;并不是杀死进程，要杀死进程需要:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; -KILL 27267 
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; -SIGKILL 27267 
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; -9 27267 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;-KILL&lt;/code&gt;, &lt;code&gt;-SIGKILL&lt;/code&gt;, &lt;code&gt;-9&lt;/code&gt;等价，都是要传输的信号，&lt;code&gt;27267&lt;/code&gt;是进程PID。&lt;code&gt;kill&lt;/code&gt;可以传输的信号有很多&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; -l
HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细数一下，&lt;code&gt;KILL&lt;/code&gt;正好是第九个 :)&lt;/p&gt;

&lt;p&gt;当进程捕获信号以后，可以对该信号做出相应的处理，也可以忽略，这也是为什么&lt;code&gt;Ctrl+C&lt;/code&gt;(相当于发出一个中断信号)有时候不管用。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>算法笔记一</title>
   <link href="http://localhost:4000/2016/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
   <updated>2016-04-06T00:00:00+08:00</updated>
   <id>http://localhost:4000/2016/04/06/算法笔记</id>
   <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于刘汝佳的《算法竞赛入门经典训练指南》第一章，总结阅读第一章的收获&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1&quot;&gt;1. 新的算法&lt;/h2&gt;

&lt;h3 id=&quot;1-1-floyd&quot;&gt;1.1 Floyd 判圈算法&lt;/h3&gt;

&lt;h4 id=&quot;&gt;算法简介&lt;/h4&gt;

&lt;p&gt;Floyd判圈算法(Floyd&amp;#39;s Cycle-Finding Algorithm) 在&lt;a href=&quot;https://uva.onlinejudge.org/external/115/11549.pdf&quot;&gt;计算器谜题&lt;/a&gt;中提到。其实对于判圈，我们有一种很直觉的算法:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//伪代码
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findCycle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hashTable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//哈希表 存储已访问过的节点
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//该节点已经访问过，发现环
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//未发现环
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这种算法空间开销较大。&lt;/p&gt;

&lt;p&gt;Floyd 判圈算法能够在 $O(n)$ 的时间复杂度和 $O(1)$ 的空间复杂度内，判断是否存在环、环的起点、计算环的长度。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//伪代码
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycleLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cycleStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//判断环是否存在
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//n2已经到达链表末尾，没有环
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//发现环
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//环的长度
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cycleLen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//环起点
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cycleStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;&gt;证明&lt;/h4&gt;

&lt;p&gt;对于Floyd判圈算法判断环是否存在的证明很容易想到，如果有环，另个速度不同的指针陷入无限循环中一定会相遇，若速度快的指针可以到达末端则不存在环。求环的长度同样很简单。&lt;/p&gt;

&lt;p&gt;​Floyd判圈算法求环的起点，&lt;a href=&quot;https://www.quora.com/How-does-Floyds-cycle-finding-algorithm-work/answer/Atul-Yadav-2&quot;&gt;Quora上的回答&lt;/a&gt;非常精彩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/hychn/hychn.github.io/blob/master/img/floyd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;速度较慢的指针走过的距离为: $slowDistance = x+y$ &lt;/p&gt;

&lt;p&gt;速度较快的指针走过的距离为: $fastDistance= x+y+z+y $&lt;/p&gt;

&lt;p&gt;​ 另外我们知道快指针的速度是慢指针的两倍，所以在相同的时间内，$fastDistance = 2 \times slowDistance$， 所以我们可以推出:
$$
\begin{align}
2(x+y)&amp;amp; = x+y+z+y\\
x &amp;amp;=z
\end{align}
$$
​记住之前指针环绕圈的方向是顺时针（逆时针同理，但是两个指针的方向必须是一样的），把其中一个指针的位置重置到首端（假设为p1），两个指针都以速度$1$移动。因为$x = z$，当p1运动距离$x$，p2运动$z$，两个指针恰好相遇到环的起点。&lt;/p&gt;

&lt;h4 id=&quot;&gt;使用范围&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;此部分是个人想法，欢迎指正&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​我们最熟悉的判断环的算法是在图论中，同样简单而实用。利用一个&lt;code&gt;marked[]&lt;/code&gt;数组，利用深度优先搜索，如果某一节点已经被标记过并且不是该节点的父节点，则发现环。&lt;/p&gt;

&lt;p&gt;​我们发现Floyd判圈算法&lt;strong&gt;一般应用在出度为1的情况&lt;/strong&gt;，那是否可以应用到复杂的图中呢？在复杂的图中，从一个节点可以到不只一个节点，我们除了保存两个速度不同的指针，最终还必须保存从该节点出发的哪些节点被访问过哪些没有被访问，再使用Floyd算法意义就不大了。所以Floyd算法应该应用在，经过某些规则，有且仅有一个新节点可以从该点到达，这个过程可以是链表的访问，也可以是某种函数计算。&lt;/p&gt;

&lt;h3 id=&quot;1-2&quot;&gt;1.2 中间相遇算法&lt;/h3&gt;

&lt;p&gt;​中间相遇算法(meet in themiddle)在&lt;a href=&quot;http://acm.tju.edu.cn/toj/vcontest/showp2464_J.html&quot;&gt;侏罗纪&lt;/a&gt;中用到。中间相遇算法实际上是暴力搜索时的一种小技巧，下面是一道经典例题:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给出N(N$\leq$ 40)个整数，每个整数的大小为 $10^{12}$ ，找出集合中元素的和小于或者等于S ( S $\leq 10^{18}$)最大的集合（determine the largest sum subset having sum less than or equal S）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​考虑到集合中元素可以是无序的，虽然$2^{40}$无法暴力求解但是$2^{20}$利用暴力法是可行的。我们将N个整数划分为(S1 S2)两个集合分为前N/2个和后N/2个的集合，分别计算子集和，然后存储在集合X和Y中。将集合Y排序，遍历X中所有的元素，利用二分法在Y集合中找到&lt;code&gt;X[i]+Y[j]&amp;lt;=S&lt;/code&gt;的最大元素&lt;code&gt;Y[j]&lt;/code&gt;，不断更新&lt;code&gt;ans =max(ans,X[i]+Y[j])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​中间相遇算法适用的条件是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于集合中元素的先后顺序无要求&lt;/li&gt;
&lt;li&gt;时间复杂度比较大但是又不那么大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细内容请参考这份&lt;a href=&quot;https://www.quora.com/What-is-meet-in-the-middle-algorithm-w-r-t-competitive-programming/answer/Swarn-Avinash-Kumar&quot;&gt;Quora回答&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2&quot;&gt;2. 实用的思想&lt;/h2&gt;

&lt;h3 id=&quot;2-1&quot;&gt;2.1 二分思想&lt;/h3&gt;

&lt;p&gt;之前我对二分的理解仅限于固定的二分查找，二分查找的核心思想就两个:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组有序&lt;/li&gt;
&lt;li&gt;折半查找&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在刘汝佳的书中，我们看到很多用二分思想的例子，对谁二分？不应该再仅限于数组，如果知道一个下界&lt;code&gt;lowerBound&lt;/code&gt;的实数或者整数，还有一个&lt;code&gt;upperBound&lt;/code&gt;。那么从&lt;code&gt;lowerBound&lt;/code&gt;到&lt;code&gt;upperBound&lt;/code&gt;的实数就是天然的递增数组。我们再此基础上进行查找，同样可以压缩空间复杂度。利用二分思想的的例题很多，就不再列举。&lt;/p&gt;

&lt;h3 id=&quot;2-2&quot;&gt;2.2 维护信息&lt;/h3&gt;

&lt;p&gt;​这道&lt;a href=&quot;https://uva.onlinejudge.org/external/110/p11078.pdf&quot;&gt;开放式学分制&lt;/a&gt;的例题很有意义，将查找的时间由$O(n^2)$压缩到$O(n)$。之前在USACO上遇到一道题，也是用到了维护信息的思想。平时最习惯的就是&lt;code&gt;for(i=0;i&amp;lt;n;i++)&lt;/code&gt;这样直接开始查找，但是有些时候，上一步查找到的元素是某个局部最优解，当我们遇到更优解时才更新它。&lt;/p&gt;

&lt;h3 id=&quot;2-3&quot;&gt;2.3 高维压缩&lt;/h3&gt;

&lt;p&gt;​问题求解的思路应该是首先确定一个蠢慢但是正确的算法，然后再进一步优化，只保留最有用的信息，减少复杂度。当遇到高维问题时，我们应该首先从低纬度的问题考虑，尝试能否从低维扩展到高维。如这道&lt;a href=&quot;https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=1696&quot;&gt;三维矩阵求和最大的子矩阵&lt;/a&gt;，首先考虑到子矩阵一定是连续的，想到一个相似的一维问题，求数组和最大的连续子数组，这个可以再$O(n)$内解决。能否扩展到二维？对于一个二维的子矩阵，可以以x或者y为方向进行压缩（求和），变换成一个等价问题的一维数组。&lt;/p&gt;

&lt;p&gt;​当我们找到压缩的方法之后，压缩的时间复杂度成为一个问题，可以利用接下来讲的前缀思想进行预计算。&lt;/p&gt;

&lt;h3 id=&quot;2-4&quot;&gt;2.4 前缀思想&lt;/h3&gt;

&lt;p&gt;​前缀思想最初接触到的就是计算序列$A_i,A_{i+1},\dots,A_{j}$的序列和的时候，可以预计算数组B，$B_i = A_0, A_1,\dots,A{i}$ 则序列可以用$B_j-B_{i-1}$在$O(1)$的时间内得到。前缀的思想可以推广到高维，而且曾经在一道二叉树的动态规划题目中也遇到过。当求某些连续的元素时，可以考虑是否利用前缀的思想在有限次运算中得到。&lt;/p&gt;

&lt;h2 id=&quot;3&quot;&gt;3. 总结&lt;/h2&gt;

&lt;p&gt;​我之前学习了sedgewick老先生开设的算法课，那时候算法给我的感觉和现在完全是不同的，当时感觉，算法就是这样堂堂正正的、严谨苛刻的，课程中讲的都是十分经典的算法。但是自己刷题还有看刘汝佳这本书，才感觉到世界深深的恶意……算法给我的感觉是天马行空的，现实的问题是如此之多，有很多小巧精致的算法，或者说思想和技巧等待我去学习实践。&lt;/p&gt;

&lt;p&gt;​ &lt;/p&gt;

&lt;p&gt;​ &lt;/p&gt;

&lt;p&gt;​ &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sponsor Search</title>
   <link href="http://localhost:4000/2016/03/02/Sponser-search/"/>
   <updated>2016-03-02T00:00:00+08:00</updated>
   <id>http://localhost:4000/2016/03/02/Sponser-search</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#INTRODUCTION&quot;&gt;INTRODUCTION&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Implementation%20Approaches&quot;&gt;Implementation Approaches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#The%20Two%20Phases%20Of%20Ad%20Selection&quot;&gt;The Two Phases Of Ad Selection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#EXACT%20MATCH&quot;&gt;EXACT MATCH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ADVANCED%20MATCH&quot;&gt;ADVANCED MATCH&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Query%20Rewriting%20Basing%20On%20Query%20Logs&quot;&gt;Query Rewriting Basing On Query Logs&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Definition%20Of%20Query%20Pair&quot;&gt;Definition Of Query Pair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Phrase%20Substitutions&quot;&gt;Phrase Substitutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Identifying%20Significant%20Query%20Pairs%20And%20Phrase%20Pairs&quot;&gt;Identifying Significant Query Pairs And Phrase Pairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Generating%20Candidates&quot;&gt;Generating Candidates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Query%20Rewriting%20Basing%20On%20Click%20Data&quot;&gt;Query Rewriting Basing On Click Data&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Problem%20Definition&quot;&gt;Problem Definition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Absorbing%20Random%20Walk%20Algorithms&quot;&gt;Absorbing Random Walk Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;INTRODUCTION&quot;&gt;INTRODUCTION&lt;/h2&gt;

&lt;p&gt;But for the SS, the web will be much more small. Once a user type the
queries and browse on the search engines, the advertiser will bid for
this queries and the winner’s Ad will be shown with the result. The
advertiser want the conversion, the network want the revenue, and the
user want the relevance. The cure problem to satisfy advertisers, users,
and the netwrork is to select the relevant textual ad.&lt;/p&gt;

&lt;p&gt;there are 3 technique mentioned in the ppt, &lt;strong&gt;EM(Exact Match)&lt;/strong&gt;, &lt;strong&gt;AM&lt;/strong&gt;\
&lt;strong&gt;(Advanced Match)&lt;/strong&gt;, and &lt;strong&gt;PM(Phase Match)&lt;/strong&gt;. EM is using for the
frequently occured queries, we’ll talk in section 1. The most
complicated technique is AM. AM is born for the long tail of queries,
because more than 80% of queries occur one time. The challenge of AM is
queries re-writting, we’ll talk in section 2. For section 3, we’ll talk
the problem remain to be solved in the new term.&lt;/p&gt;

&lt;h3 id=&quot;Implementation Approaches&quot;&gt;Implementation Approaches&lt;/h3&gt;

&lt;h4 id=&quot;the-data-base-approach-original-overture-approach&quot;&gt;&lt;strong&gt;The data base approach&lt;/strong&gt;(original Overture approach)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ads are records in a data base&lt;/li&gt;
&lt;li&gt;The bid phrase (BP) is an attribute&lt;/li&gt;
&lt;li&gt;On query q, for EM consider all ads with BP=q&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;the-ir-approach-modern-view&quot;&gt;&lt;strong&gt;The IR approach&lt;/strong&gt;(modern view)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ads are documents in an ad corpus&lt;/li&gt;
&lt;li&gt;The bid phrase is a meta-datum&lt;/li&gt;
&lt;li&gt;On query q run q against the ad corpus

&lt;ul&gt;
&lt;li&gt;Have a suitable ranking function (more later)&lt;/li&gt;
&lt;li&gt;BP = q (exact match) has high weight&lt;/li&gt;
&lt;li&gt;No distinction between AM and EM&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;The Two Phases Of Ad Selection&quot;&gt;The Two Phases Of Ad Selection&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ad Retrieval: Consider the whole ad corpus and select a set of most
viable candidates (e.g. 100)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ad Reordering: Re-score the candidates using a more elaborate
scoring function to produce the final ordering&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;EXACT MATCH&quot;&gt;EXACT MATCH&lt;/h2&gt;

&lt;p&gt;What’s EM?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;queries = BP(bid phrase)&lt;/li&gt;
&lt;li&gt;e.g. if the users query is “shoes”, then only the bid phrase “shoes”
will match, the “sports shoes”, “shoe” or “shoees”… will fail
to match.&lt;/li&gt;
&lt;li&gt;this matching type will raise up the CTR but the volume will be low,
in other words, it will reach less users.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ADVANCED MATCH&quot;&gt;ADVANCED MATCH&lt;/h2&gt;

&lt;h3 id=&quot;Query Rewriting Basing On Query Logs&quot;&gt;Query Rewriting Basing On Query Logs&lt;/h3&gt;

&lt;h4 id=&quot;Definition Of Query Pair&quot;&gt;Definition Of Query Pair&lt;/h4&gt;

&lt;p&gt;The data used comes from logs of user web accesses. This data contains
web searches annotated with user ID and timestamp. A *candidate
reformulation*is a pair of successive queries issued by a single user on
a single day. Candidate reformulations will also be referred to as query
pairs. &lt;/p&gt;

&lt;p&gt;$$\begin{align}
\text{candidate}&amp;amp;\text{Query}\text{Pairs}(user_{i},day_{i})=\{\langle q_{1},q_{2} \rangle:(q_{1}\ne q_{2})\land \\
&amp;amp;\exists t: query_{t}(user_{i}, q_{1}) \land query_{t+1}(user_{i}, q_{2})\}\end{align}
$$&lt;/p&gt;

&lt;h4 id=&quot;Phrase Substitutions&quot;&gt;Phrase Substitutions&lt;/h3&gt;

The repeated searches for the same terms, as well as query pair
sequences repeated by the same user on the same day. We then aggregate
over users, so the data for a single day consists of all candidate
reformulations for all users for that day.

then use the phrases identified by high point-wise mutual information we
segment queries into phrase for example “(new york) (maps)” or “(britney
spears) (mp3s)”. where we set the threshold κ to be
8$$\frac{P(\alpha, \beta)}{P(\alpha),P(\beta)} &gt; \kappa$$

&lt;h4 id=&quot;Identifying Significant Query Pairs And Phrase Pairs&quot;&gt;Identifying Significant Query Pairs And Phrase Pairs&lt;/h4&gt;

&lt;p&gt;In order to distinguish related query and phrase pairs from candidate
pairs that are unrelated, we use the pair indepen- dence hypothesis
likelihood ratio. This metric tests the hypothesis that the probability
of term q2 is the same whether term q1 has been seen or not, by
calculating the likelihood of the observed data under a binomial
distribution using probabilities derived using each hypothesis&lt;/p&gt;

&lt;p&gt;$$\begin{aligned}
    H_{1}:P(q_{2}|q_{1})=&amp;amp;p=P(q_{2}|\neg q_{1})\\
H_{2}:P(q_{2}|q_{1})=p_{1}&amp;amp;\ne p_{2}=P(q_{2}|\neg q_{1}) \end{aligned}
$$&lt;/p&gt;

&lt;p&gt;The likelihood score is $$\lambda = \frac{L(H_{1})}{L(H_{2})}$$ The test
statistic $-2 \log \lambda$ is asymptotically $\chi^{2}$ distributed.
Therefore we work with the log likelihood ratio score:
$$\text{LLR} = −2 \log \lambda = −2 \log \frac{L(H_{1})}{L(H_{2})}$$ A
high value for the likelihood ratio suggests that there is a strong
dependence between term $q_1$ and term $q_2$. We refer to query pairs
and phrase pairs above a threshold for the LLR score as
&lt;em&gt;substitutables&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;Generating Candidates&quot;&gt;Generating Candidates&lt;/h4&gt;

&lt;p&gt;We seek to generate statistically significant related queries for
arbitrary input queries. For frequent queries, we may have many
suggestions. But for less frequent queries, maybe there is no
statistically significant related queries. Because of the long tail, the
less frequent queries has a large fraction of the whole queries.&lt;/p&gt;

&lt;p&gt;In the same way as we generated the phrase-substitutables, we can break
up the input query into segments, and replace one or several segments by
statistically significant related segments. This will help cover the
infrequent queries.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;generate $m$ candidate whole-query substitutions
$q_i\mapsto q_{i1}, q_{i2}\dots q_{im} $&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;segment query into phrases $p_1\dots p_n $&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;for each phrase $p_i $&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  generate $k$ phrase$-$substitutions
$p_i\mapsto p_{i1}, p_{i2}\dots p_{ik} $&lt;/li&gt;
&lt;li&gt;  generate new query from a combination of original phrases and
new phrases: $q_i \mapsto p_1\dots p_j^{\prime}\dots p_n$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;more information[^1]&lt;/p&gt;

&lt;h3 id=&quot;Query Rewriting Basing On Click Data&quot;&gt;Query Rewriting Basing On Click Data&lt;/h3&gt;

&lt;h2 id=&quot;query-rewriting-basing-on-click-data&quot;&gt;Query Rewriting Basing On Click Data&lt;/h2&gt;

&lt;h4 id=&quot;Problem Definition&quot;&gt;Problem Definition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We call the set of engine click set $\mathcal L$, which is
consisted with tuples $\langle q, u, f_{qu} \rangle$. Where $u$
represent the URL and the $q$ represent the query. What’s more,
$f_{qu} $ is the number of times that the users issued query $q$ to
the search engine and clicked on URL $u$. And
$\mathcal Q\  \text{and}\ \mathcal U$ is the set if all
queries and all URLs.
We will consider clock log $\mathcal L$ as a bipartite graph
$\mathcal G = (\mathcal Q,\mathcal U, \mathcal E)$, and
$(q, u)\in E \text{ with weight} f_{qu}$.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And we define a &lt;em&gt;concepts&lt;/em&gt; set
$\mathcal C = {c_{1}, c_{2}, \dots, c_{k} } $. The element in
$\mathcal C$ can be only one concept, such as “shoes” , in more
complex cases we may have different classes in a taxonomy.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A &lt;em&gt;seed set&lt;/em&gt;
$\mathcal S \subseteq\mathcal U\times\mathcal C$, and the
seed set $\mathcal S$ is consists of $\langle u, c\rangle$ pairs.
We can regard this as label the URL with concept $c_{k}$.[^2]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;Absorbing Random Walk Algorithms&quot;&gt;Absorbing Random Walk Algorithms&lt;/h4&gt;

&lt;p&gt;Intuitively the queries (and URLs) are related to the concept of shoes
because they are connected closely in the graph to the seed set that
represents this concept.&lt;/p&gt;

&lt;p&gt;For some query $q \in\mathcal Q$ , we compute the affinity of $q$ to
some seed node $s \in\mathcal S$ as the probability that a random
walk that starts from $q$ ends up at node $s$. The affinity is the
probability that $q$ belongs to concept $c_{i}$ as seed $s$.&lt;/p&gt;

&lt;p&gt;Note that in this walk the nodes in the seed set act as &lt;em&gt;absorbing
nodes&lt;/em&gt;, that is, sink nodes in the state transition graph from which the
random walk cannot escape. The probability of absorbing nodes are
certainly $1$, which is easy to understand.&lt;/p&gt;

&lt;p&gt;And the further away the queries and URLs from seed sets’ URLs, the less
related it should be to the URL’s class. We model this by introducing an
absorbing “null class” node $\omega$ to the graph.&lt;/p&gt;

&lt;p&gt;Performing a random walk for every query in the graph is computationally
prohibitive for a large graph. However, there is a simple iterative
algorithm that can compute the class probabilities efficiently. We will
now describe the al- gorithm for the case that we have a single concept
$c$ (that is, $\mathcal C = {c}$), and then show how to generalize to
the case of multiple classes.&lt;/p&gt;

&lt;p&gt;Let $\ell_q $ (or $\ell_u $ ) denote the random variable pertaining to
the concept label for query $q$ (or URL $u$). We want to compute
$P(\ell_{q} = c) $Let $\alpha$ be the probability of making a transition
to the null class absorbing node, from any node in the graph. Then we
have that:
$$
P(\ell_q = c) = (1-\alpha) \sum_{u:(q,u)\in E}w_{qu}P(\ell_{u} = c)\tag{1}
$$
where $$w_{qu} = \frac{f_{qu}}{\sum_{u:(q,u)\in E}f_{qu}}$$ we have that
$P(\ell_u = c) = 1 $ if the pair $\langle u, c\rangle$ belongs in the
seed set, and zero otherwise&lt;/p&gt;

&lt;p&gt;For all other URLs, the probability $P(\ell_{u} = c) $ is again
recursively computed as:
$$P(\ell_u = c) = (1-\alpha) \sum_{q:(u,q)\in E}w_{uq}P(\ell_{q} = c) \tag{2}$$
where $$w_{uq} = \frac{f_{uq}}{\sum_{q:(u,q)\in E}f_{uq}}$$&lt;/p&gt;

&lt;h4 id=&quot;algorithm-1-the-arw-for-single-class&quot;&gt;&lt;strong&gt;Algorithm 1&lt;/strong&gt; The ARW for single class:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Require&lt;/strong&gt;the seed set $\mathcal S$ for class $c$, the click-graph
$\mathcal G$, the threshold parameter $\gamma$ , the transition
probability $\alpha$ to $\omega$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ensure&lt;/strong&gt; $P (\ell_{q} = c)$, for every query q&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt; $u \in \mathcal S$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u}=c)=1$
&lt;strong&gt;end for&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;repeat&lt;/strong&gt; &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $q \in \mathcal Q$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{q} = c)=(1-\alpha)\sum_{u:(q,u)\in E}\omega_{qu}P(\ell_{u} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{q} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{q} = c) = 0 $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $u \in \mathcal U \backslash S$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u} = c)=(1-\alpha)\sum_{q:(u,q)\in E}\omega_{uq}P(\ell_{q} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{u} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{u} = c) = 0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;until&lt;/strong&gt; convergence&lt;/p&gt;

&lt;p&gt;Output $P (\ell_{q} = c)$, for every query $q$ and class $\mathcal Q $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The algorithm generalizes naturally to the case where there are multiple
concepts, but this process is memory intensive since it requires to
maintain probability vectors for all $k$ classes. Furthermore, the
fraction of the graph that will be explored will increase substantially
even if we prune nodes with low probabilities, since the size of the
seed set may be significantly larger.&lt;/p&gt;

&lt;p&gt;This problem can be addressed by considering the con- cepts one at the
time. Let $\mathcal S = \mathcal S_1, \dots\mathcal S_k $be
the partition of the seed set into the k concept. Apllying Algorithms 1
directly for each $\mathcal S_{i}$ is incoreect, because we ignore an
important information: $\mathcal S\backslash\mathcal S_i $ is
null class of $\mathcal S_i $. Apllying with this, we will explore
much smaller fraction of click graphy. we fix the probability of the
nodes in $\mathcal S \backslash\mathcal S_i$ to belong to the
class $c_i$ to zero, thus making them into null absorbing nodes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Require&lt;/strong&gt;the seed set $\mathcal S$ for class $c$, the click-graph
$\mathcal G$, the threshold parameter $\gamma$ , the transition
probability $\alpha$ to $\omega$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;algorithm-2-the-arw-for-multiple-class&quot;&gt;&lt;strong&gt;Algorithm 2&lt;/strong&gt; The ARW for multiple class:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Require&lt;/strong&gt; the seed set $\mathcal S = \{\mathcal S_{1},\dots,\mathcal S_{k}\}$ for concepts $\mathcal C = \{c_{1},\dots,c_{k}\} $, the click-graph $\mathcal G$ the threshold parameter$\gamma $, the transition probability $\alpha$ to $\omega $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ensure&lt;/strong&gt; $P (\ell_{q} = c)$, for every query q&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $c_{i} \in \mathcal C$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt; $u \in \mathcal S \backslash \mathcal S_{i}$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u}=c_{i})=0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt; $u \in \mathcal S_{i}$ &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u}=c)=1$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;repeat&lt;/strong&gt; &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $q \in \mathcal Q$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{q} = c)=(1-\alpha)\sum_{u:(q,u)\in E}\omega_{qu}P(\ell_{u} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{q} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{q} = c) = 0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $u \in \mathcal U \backslash S$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u} = c)=(1-\alpha)\sum_{q:(u,q)\in E}\omega_{uq}P(\ell_{q} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{u} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{u} = c) = 0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;until&lt;/strong&gt; convergence&lt;/p&gt;

&lt;p&gt;Output $P (\ell_{q} = c)$, for every query $q$ and class $\mathcal C $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;more information here[^3]&lt;/p&gt;

&lt;h1 id=&quot;remain-to-be-solved&quot;&gt;REMAIN TO BE SOLVED&lt;/h1&gt;

&lt;p&gt;The problems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;other algorithms in the paper, and the comparasion between them&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;how to bid for AM&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[^1]: Generating Query Substitutions: Jones et al, in Proc of WWW 2006&lt;/p&gt;

&lt;p&gt;[^2]: we can also define the seed set as labeled queries or a mix of
    quries and URLs. For simplicity, we will restrict ourselves to the
    case that the seed set consists only of URLs.&lt;/p&gt;

&lt;p&gt;[^3]: Using the Wisdom of the Crowds for Keyword Generation: Fuxman et
    al., In proc of WWW 2004&lt;/p&gt;
</content>
 </entry>
 

</feed>
