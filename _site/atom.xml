<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Huayang</title>
 <link href="http://agrowingtree.github.io/atom.xml" rel="self"/>
 <link href="http://agrowingtree.github.io/"/>
 <updated>2016-12-02T17:52:25+08:00</updated>
 <id>http://agrowingtree.github.io</id>
 <author>
   <name>Huayang Li</name>
   <email>waajoenglei@gmail.com</email>
 </author>

 
 <entry>
   <title>算法笔记一</title>
   <link href="http://agrowingtree.github.io/2016/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
   <updated>2016-04-06T00:00:00+08:00</updated>
   <id>http://agrowingtree.github.io/2016/04/06/算法笔记</id>
   <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文基于刘汝佳的《算法竞赛入门经典训练指南》第一章，总结阅读第一章的收获&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1&quot;&gt;1. 新的算法&lt;/h2&gt;

&lt;h3 id=&quot;1-1-floyd&quot;&gt;1.1 Floyd 判圈算法&lt;/h3&gt;

&lt;h4 id=&quot;&gt;算法简介&lt;/h4&gt;

&lt;p&gt;Floyd判圈算法(Floyd&amp;#39;s Cycle-Finding Algorithm) 在&lt;a href=&quot;https://uva.onlinejudge.org/external/115/11549.pdf&quot;&gt;计算器谜题&lt;/a&gt;中提到。其实对于判圈，我们有一种很直觉的算法:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//伪代码
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findCycle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hashTable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//哈希表 存储已访问过的节点
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//该节点已经访问过，发现环
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//未发现环
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这种算法空间开销较大。&lt;/p&gt;

&lt;p&gt;Floyd 判圈算法能够在 $O(n)$ 的时间复杂度和 $O(1)$ 的空间复杂度内，判断是否存在环、环的起点、计算环的长度。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//伪代码
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycleLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cycleStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//判断环是否存在
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//n2已经到达链表末尾，没有环
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//发现环
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//环的长度
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cycleLen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//环起点
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mylist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cycleStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;&gt;证明&lt;/h4&gt;

&lt;p&gt;对于Floyd判圈算法判断环是否存在的证明很容易想到，如果有环，另个速度不同的指针陷入无限循环中一定会相遇，若速度快的指针可以到达末端则不存在环。求环的长度同样很简单。&lt;/p&gt;

&lt;p&gt;​Floyd判圈算法求环的起点，&lt;a href=&quot;https://www.quora.com/How-does-Floyds-cycle-finding-algorithm-work/answer/Atul-Yadav-2&quot;&gt;Quora上的回答&lt;/a&gt;非常精彩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/hychn/hychn.github.io/img/floyd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;速度较慢的指针走过的距离为: $slowDistance = x+y$ &lt;/p&gt;

&lt;p&gt;速度较快的指针走过的距离为: $fastDistance= x+y+z+y $&lt;/p&gt;

&lt;p&gt;​ 另外我们知道快指针的速度是慢指针的两倍，所以在相同的时间内，$fastDistance = 2 \times slowDistance$， 所以我们可以推出:
$$
\begin{align}
2(x+y)&amp;amp; = x+y+z+y\\
x &amp;amp;=z
\end{align}
$$
​记住之前指针环绕圈的方向是顺时针（逆时针同理，但是两个指针的方向必须是一样的），把其中一个指针的位置重置到首端（假设为p1），两个指针都以速度$1$移动。因为$x = z$，当p1运动距离$x$，p2运动$z$，两个指针恰好相遇到环的起点。&lt;/p&gt;

&lt;h4 id=&quot;&gt;使用范围&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;此部分是个人想法，欢迎指正&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​我们最熟悉的判断环的算法是在图论中，同样简单而实用。利用一个&lt;code&gt;marked[]&lt;/code&gt;数组，利用深度优先搜索，如果某一节点已经被标记过并且不是该节点的父节点，则发现环。&lt;/p&gt;

&lt;p&gt;​我们发现Floyd判圈算法&lt;strong&gt;一般应用在出度为1的情况&lt;/strong&gt;，那是否可以应用到复杂的图中呢？在复杂的图中，从一个节点可以到不只一个节点，我们除了保存两个速度不同的指针，最终还必须保存从该节点出发的哪些节点被访问过哪些没有被访问，再使用Floyd算法意义就不大了。所以Floyd算法应该应用在，经过某些规则，有且仅有一个新节点可以从该点到达，这个过程可以是链表的访问，也可以是某种函数计算。&lt;/p&gt;

&lt;h3 id=&quot;1-2&quot;&gt;1.2 中间相遇算法&lt;/h3&gt;

&lt;p&gt;​中间相遇算法(meet in themiddle)在&lt;a href=&quot;http://acm.tju.edu.cn/toj/vcontest/showp2464_J.html&quot;&gt;侏罗纪&lt;/a&gt;中用到。中间相遇算法实际上是暴力搜索时的一种小技巧，下面是一道经典例题:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给出N(N$\leq$ 40)个整数，每个整数的大小为 $10^{12}$ ，找出集合中元素的和小于或者等于S ( S $\leq 10^{18}$)最大的集合（determine the largest sum subset having sum less than or equal S）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​考虑到集合中元素可以是无序的，虽然$2^{40}$无法暴力求解但是$2^{20}$利用暴力法是可行的。我们将N个整数划分为(S1 S2)两个集合分为前N/2个和后N/2个的集合，分别计算子集和，然后存储在集合X和Y中。将集合Y排序，遍历X中所有的元素，利用二分法在Y集合中找到&lt;code&gt;X[i]+Y[j]&amp;lt;=S&lt;/code&gt;的最大元素&lt;code&gt;Y[j]&lt;/code&gt;，不断更新&lt;code&gt;ans =max(ans,X[i]+Y[j])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​中间相遇算法适用的条件是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于集合中元素的先后顺序无要求&lt;/li&gt;
&lt;li&gt;时间复杂度比较大但是又不那么大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详细内容请参考这份&lt;a href=&quot;https://www.quora.com/What-is-meet-in-the-middle-algorithm-w-r-t-competitive-programming/answer/Swarn-Avinash-Kumar&quot;&gt;Quora回答&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2&quot;&gt;2. 实用的思想&lt;/h2&gt;

&lt;h3 id=&quot;2-1&quot;&gt;2.1 二分思想&lt;/h3&gt;

&lt;p&gt;之前我对二分的理解仅限于固定的二分查找，二分查找的核心思想就两个:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组有序&lt;/li&gt;
&lt;li&gt;折半查找&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在刘汝佳的书中，我们看到很多用二分思想的例子，对谁二分？不应该再仅限于数组，如果知道一个下界&lt;code&gt;lowerBound&lt;/code&gt;的实数或者整数，还有一个&lt;code&gt;upperBound&lt;/code&gt;。那么从&lt;code&gt;lowerBound&lt;/code&gt;到&lt;code&gt;upperBound&lt;/code&gt;的实数就是天然的递增数组。我们再此基础上进行查找，同样可以压缩空间复杂度。利用二分思想的的例题很多，就不再列举。&lt;/p&gt;

&lt;h3 id=&quot;2-2&quot;&gt;2.2 维护信息&lt;/h3&gt;

&lt;p&gt;​这道&lt;a href=&quot;https://uva.onlinejudge.org/external/110/p11078.pdf&quot;&gt;开放式学分制&lt;/a&gt;的例题很有意义，将查找的时间由$O(n^2)$压缩到$O(n)$。之前在USACO上遇到一道题，也是用到了维护信息的思想。平时最习惯的就是&lt;code&gt;for(i=0;i&amp;lt;n;i++)&lt;/code&gt;这样直接开始查找，但是有些时候，上一步查找到的元素是某个局部最优解，当我们遇到更优解时才更新它。&lt;/p&gt;

&lt;h3 id=&quot;2-3&quot;&gt;2.3 高维压缩&lt;/h3&gt;

&lt;p&gt;​问题求解的思路应该是首先确定一个蠢慢但是正确的算法，然后再进一步优化，只保留最有用的信息，减少复杂度。当遇到高维问题时，我们应该首先从低纬度的问题考虑，尝试能否从低维扩展到高维。如这道&lt;a href=&quot;https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=1696&quot;&gt;三维矩阵求和最大的子矩阵&lt;/a&gt;，首先考虑到子矩阵一定是连续的，想到一个相似的一维问题，求数组和最大的连续子数组，这个可以再$O(n)$内解决。能否扩展到二维？对于一个二维的子矩阵，可以以x或者y为方向进行压缩（求和），变换成一个等价问题的一维数组。&lt;/p&gt;

&lt;p&gt;​当我们找到压缩的方法之后，压缩的时间复杂度成为一个问题，可以利用接下来讲的前缀思想进行预计算。&lt;/p&gt;

&lt;h3 id=&quot;2-4&quot;&gt;2.4 前缀思想&lt;/h3&gt;

&lt;p&gt;​前缀思想最初接触到的就是计算序列$A_i,A_{i+1},\dots,A_{j}$的序列和的时候，可以预计算数组B，$B_i = A_0, A_1,\dots,A{i}$ 则序列可以用$B_j-B_{i-1}$在$O(1)$的时间内得到。前缀的思想可以推广到高维，而且曾经在一道二叉树的动态规划题目中也遇到过。当求某些连续的元素时，可以考虑是否利用前缀的思想在有限次运算中得到。&lt;/p&gt;

&lt;h2 id=&quot;3&quot;&gt;3. 总结&lt;/h2&gt;

&lt;p&gt;​我之前学习了sedgewick老先生开设的算法课，那时候算法给我的感觉和现在完全是不同的，当时感觉，算法就是这样堂堂正正的、严谨苛刻的，课程中讲的都是十分经典的算法。但是自己刷题还有看刘汝佳这本书，才感觉到世界深深的恶意……算法给我的感觉是天马行空的，现实的问题是如此之多，有很多小巧精致的算法，或者说思想和技巧等待我去学习实践。&lt;/p&gt;

&lt;p&gt;​ &lt;/p&gt;

&lt;p&gt;​ &lt;/p&gt;

&lt;p&gt;​ &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sponsor Search</title>
   <link href="http://agrowingtree.github.io/2016/03/02/Sponser-search/"/>
   <updated>2016-03-02T00:00:00+08:00</updated>
   <id>http://agrowingtree.github.io/2016/03/02/Sponser-search</id>
   <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#INTRODUCTION&quot;&gt;INTRODUCTION&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Implementation%20Approaches&quot;&gt;Implementation Approaches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#The%20Two%20Phases%20Of%20Ad%20Selection&quot;&gt;The Two Phases Of Ad Selection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#EXACT%20MATCH&quot;&gt;EXACT MATCH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#ADVANCED%20MATCH&quot;&gt;ADVANCED MATCH&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Query%20Rewriting%20Basing%20On%20Query%20Logs&quot;&gt;Query Rewriting Basing On Query Logs&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Definition%20Of%20Query%20Pair&quot;&gt;Definition Of Query Pair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Phrase%20Substitutions&quot;&gt;Phrase Substitutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Identifying%20Significant%20Query%20Pairs%20And%20Phrase%20Pairs&quot;&gt;Identifying Significant Query Pairs And Phrase Pairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Generating%20Candidates&quot;&gt;Generating Candidates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Query%20Rewriting%20Basing%20On%20Click%20Data&quot;&gt;Query Rewriting Basing On Click Data&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Problem%20Definition&quot;&gt;Problem Definition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Absorbing%20Random%20Walk%20Algorithms&quot;&gt;Absorbing Random Walk Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;INTRODUCTION&quot;&gt;INTRODUCTION&lt;/h2&gt;

&lt;p&gt;But for the SS, the web will be much more small. Once a user type the
queries and browse on the search engines, the advertiser will bid for
this queries and the winner’s Ad will be shown with the result. The
advertiser want the conversion, the network want the revenue, and the
user want the relevance. The cure problem to satisfy advertisers, users,
and the netwrork is to select the relevant textual ad.&lt;/p&gt;

&lt;p&gt;there are 3 technique mentioned in the ppt, &lt;strong&gt;EM(Exact Match)&lt;/strong&gt;, &lt;strong&gt;AM&lt;/strong&gt;\
&lt;strong&gt;(Advanced Match)&lt;/strong&gt;, and &lt;strong&gt;PM(Phase Match)&lt;/strong&gt;. EM is using for the
frequently occured queries, we’ll talk in section 1. The most
complicated technique is AM. AM is born for the long tail of queries,
because more than 80% of queries occur one time. The challenge of AM is
queries re-writting, we’ll talk in section 2. For section 3, we’ll talk
the problem remain to be solved in the new term.&lt;/p&gt;

&lt;h3 id=&quot;Implementation Approaches&quot;&gt;Implementation Approaches&lt;/h3&gt;

&lt;h4 id=&quot;the-data-base-approach-original-overture-approach&quot;&gt;&lt;strong&gt;The data base approach&lt;/strong&gt;(original Overture approach)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ads are records in a data base&lt;/li&gt;
&lt;li&gt;The bid phrase (BP) is an attribute&lt;/li&gt;
&lt;li&gt;On query q, for EM consider all ads with BP=q&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;the-ir-approach-modern-view&quot;&gt;&lt;strong&gt;The IR approach&lt;/strong&gt;(modern view)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ads are documents in an ad corpus&lt;/li&gt;
&lt;li&gt;The bid phrase is a meta-datum&lt;/li&gt;
&lt;li&gt;On query q run q against the ad corpus

&lt;ul&gt;
&lt;li&gt;Have a suitable ranking function (more later)&lt;/li&gt;
&lt;li&gt;BP = q (exact match) has high weight&lt;/li&gt;
&lt;li&gt;No distinction between AM and EM&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;The Two Phases Of Ad Selection&quot;&gt;The Two Phases Of Ad Selection&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ad Retrieval: Consider the whole ad corpus and select a set of most
viable candidates (e.g. 100)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ad Reordering: Re-score the candidates using a more elaborate
scoring function to produce the final ordering&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;EXACT MATCH&quot;&gt;EXACT MATCH&lt;/h2&gt;

&lt;p&gt;What’s EM?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;queries = BP(bid phrase)&lt;/li&gt;
&lt;li&gt;e.g. if the users query is “shoes”, then only the bid phrase “shoes”
will match, the “sports shoes”, “shoe” or “shoees”… will fail
to match.&lt;/li&gt;
&lt;li&gt;this matching type will raise up the CTR but the volume will be low,
in other words, it will reach less users.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ADVANCED MATCH&quot;&gt;ADVANCED MATCH&lt;/h2&gt;

&lt;h3 id=&quot;Query Rewriting Basing On Query Logs&quot;&gt;Query Rewriting Basing On Query Logs&lt;/h3&gt;

&lt;h4 id=&quot;Definition Of Query Pair&quot;&gt;Definition Of Query Pair&lt;/h4&gt;

&lt;p&gt;The data used comes from logs of user web accesses. This data contains
web searches annotated with user ID and timestamp. A *candidate
reformulation*is a pair of successive queries issued by a single user on
a single day. Candidate reformulations will also be referred to as query
pairs. &lt;/p&gt;

&lt;p&gt;$$\begin{align}
\text{candidate}&amp;amp;\text{Query}\text{Pairs}(user_{i},day_{i})=\{\langle q_{1},q_{2} \rangle:(q_{1}\ne q_{2})\land \\
&amp;amp;\exists t: query_{t}(user_{i}, q_{1}) \land query_{t+1}(user_{i}, q_{2})\}\end{align}
$$&lt;/p&gt;

&lt;h4 id=&quot;Phrase Substitutions&quot;&gt;Phrase Substitutions&lt;/h3&gt;

The repeated searches for the same terms, as well as query pair
sequences repeated by the same user on the same day. We then aggregate
over users, so the data for a single day consists of all candidate
reformulations for all users for that day.

then use the phrases identified by high point-wise mutual information we
segment queries into phrase for example “(new york) (maps)” or “(britney
spears) (mp3s)”. where we set the threshold κ to be
8$$\frac{P(\alpha, \beta)}{P(\alpha),P(\beta)} &gt; \kappa$$

&lt;h4 id=&quot;Identifying Significant Query Pairs And Phrase Pairs&quot;&gt;Identifying Significant Query Pairs And Phrase Pairs&lt;/h4&gt;

&lt;p&gt;In order to distinguish related query and phrase pairs from candidate
pairs that are unrelated, we use the pair indepen- dence hypothesis
likelihood ratio. This metric tests the hypothesis that the probability
of term q2 is the same whether term q1 has been seen or not, by
calculating the likelihood of the observed data under a binomial
distribution using probabilities derived using each hypothesis&lt;/p&gt;

&lt;p&gt;$$\begin{aligned}
    H_{1}:P(q_{2}|q_{1})=&amp;amp;p=P(q_{2}|\neg q_{1})\\
H_{2}:P(q_{2}|q_{1})=p_{1}&amp;amp;\ne p_{2}=P(q_{2}|\neg q_{1}) \end{aligned}
$$&lt;/p&gt;

&lt;p&gt;The likelihood score is $$\lambda = \frac{L(H_{1})}{L(H_{2})}$$ The test
statistic $-2 \log \lambda$ is asymptotically $\chi^{2}$ distributed.
Therefore we work with the log likelihood ratio score:
$$\text{LLR} = −2 \log \lambda = −2 \log \frac{L(H_{1})}{L(H_{2})}$$ A
high value for the likelihood ratio suggests that there is a strong
dependence between term $q_1$ and term $q_2$. We refer to query pairs
and phrase pairs above a threshold for the LLR score as
&lt;em&gt;substitutables&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;Generating Candidates&quot;&gt;Generating Candidates&lt;/h4&gt;

&lt;p&gt;We seek to generate statistically significant related queries for
arbitrary input queries. For frequent queries, we may have many
suggestions. But for less frequent queries, maybe there is no
statistically significant related queries. Because of the long tail, the
less frequent queries has a large fraction of the whole queries.&lt;/p&gt;

&lt;p&gt;In the same way as we generated the phrase-substitutables, we can break
up the input query into segments, and replace one or several segments by
statistically significant related segments. This will help cover the
infrequent queries.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;generate $m$ candidate whole-query substitutions
$q_i\mapsto q_{i1}, q_{i2}\dots q_{im} $&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;segment query into phrases $p_1\dots p_n $&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;for each phrase $p_i $&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  generate $k$ phrase$-$substitutions
$p_i\mapsto p_{i1}, p_{i2}\dots p_{ik} $&lt;/li&gt;
&lt;li&gt;  generate new query from a combination of original phrases and
new phrases: $q_i \mapsto p_1\dots p_j^{\prime}\dots p_n$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;more information[^1]&lt;/p&gt;

&lt;h3 id=&quot;Query Rewriting Basing On Click Data&quot;&gt;Query Rewriting Basing On Click Data&lt;/h3&gt;

&lt;h2 id=&quot;query-rewriting-basing-on-click-data&quot;&gt;Query Rewriting Basing On Click Data&lt;/h2&gt;

&lt;h4 id=&quot;Problem Definition&quot;&gt;Problem Definition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We call the set of engine click set $\mathcal L$, which is
consisted with tuples $\langle q, u, f_{qu} \rangle$. Where $u$
represent the URL and the $q$ represent the query. What’s more,
$f_{qu} $ is the number of times that the users issued query $q$ to
the search engine and clicked on URL $u$. And
$\mathcal Q\  \text{and}\ \mathcal U$ is the set if all
queries and all URLs.
We will consider clock log $\mathcal L$ as a bipartite graph
$\mathcal G = (\mathcal Q,\mathcal U, \mathcal E)$, and
$(q, u)\in E \text{ with weight} f_{qu}$.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And we define a &lt;em&gt;concepts&lt;/em&gt; set
$\mathcal C = {c_{1}, c_{2}, \dots, c_{k} } $. The element in
$\mathcal C$ can be only one concept, such as “shoes” , in more
complex cases we may have different classes in a taxonomy.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A &lt;em&gt;seed set&lt;/em&gt;
$\mathcal S \subseteq\mathcal U\times\mathcal C$, and the
seed set $\mathcal S$ is consists of $\langle u, c\rangle$ pairs.
We can regard this as label the URL with concept $c_{k}$.[^2]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;Absorbing Random Walk Algorithms&quot;&gt;Absorbing Random Walk Algorithms&lt;/h4&gt;

&lt;p&gt;Intuitively the queries (and URLs) are related to the concept of shoes
because they are connected closely in the graph to the seed set that
represents this concept.&lt;/p&gt;

&lt;p&gt;For some query $q \in\mathcal Q$ , we compute the affinity of $q$ to
some seed node $s \in\mathcal S$ as the probability that a random
walk that starts from $q$ ends up at node $s$. The affinity is the
probability that $q$ belongs to concept $c_{i}$ as seed $s$.&lt;/p&gt;

&lt;p&gt;Note that in this walk the nodes in the seed set act as &lt;em&gt;absorbing
nodes&lt;/em&gt;, that is, sink nodes in the state transition graph from which the
random walk cannot escape. The probability of absorbing nodes are
certainly $1$, which is easy to understand.&lt;/p&gt;

&lt;p&gt;And the further away the queries and URLs from seed sets’ URLs, the less
related it should be to the URL’s class. We model this by introducing an
absorbing “null class” node $\omega$ to the graph.&lt;/p&gt;

&lt;p&gt;Performing a random walk for every query in the graph is computationally
prohibitive for a large graph. However, there is a simple iterative
algorithm that can compute the class probabilities efficiently. We will
now describe the al- gorithm for the case that we have a single concept
$c$ (that is, $\mathcal C = {c}$), and then show how to generalize to
the case of multiple classes.&lt;/p&gt;

&lt;p&gt;Let $\ell_q $ (or $\ell_u $ ) denote the random variable pertaining to
the concept label for query $q$ (or URL $u$). We want to compute
$P(\ell_{q} = c) $Let $\alpha$ be the probability of making a transition
to the null class absorbing node, from any node in the graph. Then we
have that:
$$
P(\ell_q = c) = (1-\alpha) \sum_{u:(q,u)\in E}w_{qu}P(\ell_{u} = c)\tag{1}
$$
where $$w_{qu} = \frac{f_{qu}}{\sum_{u:(q,u)\in E}f_{qu}}$$ we have that
$P(\ell_u = c) = 1 $ if the pair $\langle u, c\rangle$ belongs in the
seed set, and zero otherwise&lt;/p&gt;

&lt;p&gt;For all other URLs, the probability $P(\ell_{u} = c) $ is again
recursively computed as:
$$P(\ell_u = c) = (1-\alpha) \sum_{q:(u,q)\in E}w_{uq}P(\ell_{q} = c) \tag{2}$$
where $$w_{uq} = \frac{f_{uq}}{\sum_{q:(u,q)\in E}f_{uq}}$$&lt;/p&gt;

&lt;h4 id=&quot;algorithm-1-the-arw-for-single-class&quot;&gt;&lt;strong&gt;Algorithm 1&lt;/strong&gt; The ARW for single class:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Require&lt;/strong&gt;the seed set $\mathcal S$ for class $c$, the click-graph
$\mathcal G$, the threshold parameter $\gamma$ , the transition
probability $\alpha$ to $\omega$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ensure&lt;/strong&gt; $P (\ell_{q} = c)$, for every query q&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt; $u \in \mathcal S$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u}=c)=1$
&lt;strong&gt;end for&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;repeat&lt;/strong&gt; &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $q \in \mathcal Q$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{q} = c)=(1-\alpha)\sum_{u:(q,u)\in E}\omega_{qu}P(\ell_{u} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{q} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{q} = c) = 0 $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $u \in \mathcal U \backslash S$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u} = c)=(1-\alpha)\sum_{q:(u,q)\in E}\omega_{uq}P(\ell_{q} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{u} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{u} = c) = 0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;until&lt;/strong&gt; convergence&lt;/p&gt;

&lt;p&gt;Output $P (\ell_{q} = c)$, for every query $q$ and class $\mathcal Q $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The algorithm generalizes naturally to the case where there are multiple
concepts, but this process is memory intensive since it requires to
maintain probability vectors for all $k$ classes. Furthermore, the
fraction of the graph that will be explored will increase substantially
even if we prune nodes with low probabilities, since the size of the
seed set may be significantly larger.&lt;/p&gt;

&lt;p&gt;This problem can be addressed by considering the con- cepts one at the
time. Let $\mathcal S = \mathcal S_1, \dots\mathcal S_k $be
the partition of the seed set into the k concept. Apllying Algorithms 1
directly for each $\mathcal S_{i}$ is incoreect, because we ignore an
important information: $\mathcal S\backslash\mathcal S_i $ is
null class of $\mathcal S_i $. Apllying with this, we will explore
much smaller fraction of click graphy. we fix the probability of the
nodes in $\mathcal S \backslash\mathcal S_i$ to belong to the
class $c_i$ to zero, thus making them into null absorbing nodes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Require&lt;/strong&gt;the seed set $\mathcal S$ for class $c$, the click-graph
$\mathcal G$, the threshold parameter $\gamma$ , the transition
probability $\alpha$ to $\omega$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;algorithm-2-the-arw-for-multiple-class&quot;&gt;&lt;strong&gt;Algorithm 2&lt;/strong&gt; The ARW for multiple class:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Require&lt;/strong&gt; the seed set $\mathcal S = \{\mathcal S_{1},\dots,\mathcal S_{k}\}$ for concepts $\mathcal C = \{c_{1},\dots,c_{k}\} $, the click-graph $\mathcal G$ the threshold parameter$\gamma $, the transition probability $\alpha$ to $\omega $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ensure&lt;/strong&gt; $P (\ell_{q} = c)$, for every query q&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $c_{i} \in \mathcal C$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt; $u \in \mathcal S \backslash \mathcal S_{i}$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u}=c_{i})=0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt; $u \in \mathcal S_{i}$ &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u}=c)=1$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;repeat&lt;/strong&gt; &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $q \in \mathcal Q$ &lt;strong&gt;do&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{q} = c)=(1-\alpha)\sum_{u:(q,u)\in E}\omega_{qu}P(\ell_{u} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{q} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{q} = c) = 0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;for all&lt;/strong&gt; $u \in \mathcal U \backslash S$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$P(\ell_{u} = c)=(1-\alpha)\sum_{q:(u,q)\in E}\omega_{uq}P(\ell_{q} = c) $&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; $P(\ell_{u} = c) &amp;lt; \gamma$ &lt;strong&gt;then&lt;/strong&gt; $P(\ell_{u} = c) = 0$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;until&lt;/strong&gt; convergence&lt;/p&gt;

&lt;p&gt;Output $P (\ell_{q} = c)$, for every query $q$ and class $\mathcal C $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;end for&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;more information here[^3]&lt;/p&gt;

&lt;h1 id=&quot;remain-to-be-solved&quot;&gt;REMAIN TO BE SOLVED&lt;/h1&gt;

&lt;p&gt;The problems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;other algorithms in the paper, and the comparasion between them&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;how to bid for AM&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[^1]: Generating Query Substitutions: Jones et al, in Proc of WWW 2006&lt;/p&gt;

&lt;p&gt;[^2]: we can also define the seed set as labeled queries or a mix of
    quries and URLs. For simplicity, we will restrict ourselves to the
    case that the seed set consists only of URLs.&lt;/p&gt;

&lt;p&gt;[^3]: Using the Wisdom of the Crowds for Keyword Generation: Fuxman et
    al., In proc of WWW 2004&lt;/p&gt;
</content>
 </entry>
 

</feed>
