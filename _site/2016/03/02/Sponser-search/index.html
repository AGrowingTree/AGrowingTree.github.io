<!DOCTYPE html>
<html lang="en">

  <head>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    <!--TeX: { equationNumbers: { autoNumber: "AMS"} },-->
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEnvironments: true,
      processEscape: true,
    },
    'HTML-CSS': {
      matchFontHeight: true,
      availableFonts: [],
      webFont: 'TeX'
    }
  });
  </script>

  <script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Sponser Advertising &middot; Huayang
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="Huayang" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
        <a href="/" title="Home">Huayang</a>

        
          &nbsp;&nbsp;&nbsp;
            <small><a href="/about">About</a></small>
        
          &nbsp;&nbsp;&nbsp;
            <small><a href="/summary">Summary</a></small>
        
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Sponser Advertising</h1>
  <time datetime="2016-03-02T00:00:00+08:00" class="post-date">02 Mar 2016</time>
  <ul>
<li><a href="#INTRODUCTION">INTRODUCTION</a>

<ul>
<li><a href="#Implementation%20Approaches">Implementation Approaches</a></li>
<li><a href="#The%20Two%20Phases%20Of%20Ad%20Selection">The Two Phases Of Ad Selection</a></li>
</ul></li>
<li><a href="#EXACT%20MATCH">EXACT MATCH</a></li>
<li><a href="#ADVANCED%20MATCH">ADVANCED MATCH</a>

<ul>
<li><a href="#Query%20Rewriting%20Basing%20On%20Query%20Logs">Query Rewriting Basing On Query Logs</a>

<ul>
<li><a href="#Definition%20Of%20Query%20Pair">Definition Of Query Pair</a></li>
<li><a href="#Phrase%20Substitutions">Phrase Substitutions</a></li>
<li><a href="#Identifying%20Significant%20Query%20Pairs%20And%20Phrase%20Pairs">Identifying Significant Query Pairs And Phrase Pairs</a></li>
<li><a href="#Generating%20Candidates">Generating Candidates</a></li>
</ul></li>
<li><a href="#Query%20Rewriting%20Basing%20On%20Click%20Data">Query Rewriting Basing On Click Data</a>

<ul>
<li><a href="#Problem%20Definition">Problem Definition</a></li>
<li><a href="#Absorbing%20Random%20Walk%20Algorithms">Absorbing Random Walk Algorithms</a></li>
</ul></li>
</ul></li>
</ul>

<h2 id="INTRODUCTION">INTRODUCTION</h2>

<p>But for the SS, the web will be much more small. Once a user type the
queries and browse on the search engines, the advertiser will bid for
this queries and the winner’s Ad will be shown with the result. The
advertiser want the conversion, the network want the revenue, and the
user want the relevance. The cure problem to satisfy advertisers, users,
and the netwrork is to select the relevant textual ad.</p>

<p>there are 3 technique mentioned in the ppt, <strong>EM(Exact Match)</strong>, <strong>AM</strong>\
<strong>(Advanced Match)</strong>, and <strong>PM(Phase Match)</strong>. EM is using for the
frequently occured queries, we’ll talk in section 1. The most
complicated technique is AM. AM is born for the long tail of queries,
because more than 80% of queries occur one time. The challenge of AM is
queries re-writting, we’ll talk in section 2. For section 3, we’ll talk
the problem remain to be solved in the new term.</p>

<h3 id="Implementation Approaches">Implementation Approaches</h3>

<h4 id="the-data-base-approach-original-overture-approach"><strong>The data base approach</strong>(original Overture approach)</h4>

<ul>
<li>Ads are records in a data base</li>
<li>The bid phrase (BP) is an attribute</li>
<li>On query q, for EM consider all ads with BP=q</li>
</ul>

<h4 id="the-ir-approach-modern-view"><strong>The IR approach</strong>(modern view)</h4>

<ul>
<li>Ads are documents in an ad corpus</li>
<li>The bid phrase is a meta-datum</li>
<li>On query q run q against the ad corpus

<ul>
<li>Have a suitable ranking function (more later)</li>
<li>BP = q (exact match) has high weight</li>
<li>No distinction between AM and EM</li>
</ul></li>
</ul>

<h3 id="The Two Phases Of Ad Selection">The Two Phases Of Ad Selection</h3>

<ul>
<li><p>Ad Retrieval: Consider the whole ad corpus and select a set of most
viable candidates (e.g. 100)</p></li>
<li><p>Ad Reordering: Re-score the candidates using a more elaborate
scoring function to produce the final ordering</p></li>
</ul>

<h2 id="EXACT MATCH">EXACT MATCH</h2>

<p>What’s EM?</p>

<ul>
<li>queries = BP(bid phrase)</li>
<li>e.g. if the users query is “shoes”, then only the bid phrase “shoes”
will match, the “sports shoes”, “shoe” or “shoees”… will fail
to match.</li>
<li>this matching type will raise up the CTR but the volume will be low,
in other words, it will reach less users.</li>
</ul>

<h2 id="ADVANCED MATCH">ADVANCED MATCH</h2>

<h3 id="Query Rewriting Basing On Query Logs">Query Rewriting Basing On Query Logs</h3>

<h4 id="Definition Of Query Pair">Definition Of Query Pair</h4>

<p>The data used comes from logs of user web accesses. This data contains
web searches annotated with user ID and timestamp. A *candidate
reformulation*is a pair of successive queries issued by a single user on
a single day. Candidate reformulations will also be referred to as query
pairs. </p>

<p>$$\begin{align}
\text{candidate}&amp;\text{Query}\text{Pairs}(user_{i},day_{i})=\{\langle q_{1},q_{2} \rangle:(q_{1}\ne q_{2})\land \\
&amp;\exists t: query_{t}(user_{i}, q_{1}) \land query_{t+1}(user_{i}, q_{2})\}\end{align}
$$</p>

<h4 id="Phrase Substitutions">Phrase Substitutions</h3>

The repeated searches for the same terms, as well as query pair
sequences repeated by the same user on the same day. We then aggregate
over users, so the data for a single day consists of all candidate
reformulations for all users for that day.

then use the phrases identified by high point-wise mutual information we
segment queries into phrase for example “(new york) (maps)” or “(britney
spears) (mp3s)”. where we set the threshold κ to be
8$$\frac{P(\alpha, \beta)}{P(\alpha),P(\beta)} > \kappa$$

<h4 id="Identifying Significant Query Pairs And Phrase Pairs">Identifying Significant Query Pairs And Phrase Pairs</h4>

<p>In order to distinguish related query and phrase pairs from candidate
pairs that are unrelated, we use the pair indepen- dence hypothesis
likelihood ratio. This metric tests the hypothesis that the probability
of term q2 is the same whether term q1 has been seen or not, by
calculating the likelihood of the observed data under a binomial
distribution using probabilities derived using each hypothesis</p>

<p>$$\begin{aligned}
    H_{1}:P(q_{2}|q_{1})=&amp;p=P(q_{2}|\neg q_{1})\\
H_{2}:P(q_{2}|q_{1})=p_{1}&amp;\ne p_{2}=P(q_{2}|\neg q_{1}) \end{aligned}
$$</p>

<p>The likelihood score is $$\lambda = \frac{L(H_{1})}{L(H_{2})}$$ The test
statistic $-2 \log \lambda$ is asymptotically $\chi^{2}$ distributed.
Therefore we work with the log likelihood ratio score:
$$\text{LLR} = −2 \log \lambda = −2 \log \frac{L(H_{1})}{L(H_{2})}$$ A
high value for the likelihood ratio suggests that there is a strong
dependence between term $q_1$ and term $q_2$. We refer to query pairs
and phrase pairs above a threshold for the LLR score as
<em>substitutables</em>.</p>

<h4 id="Generating Candidates">Generating Candidates</h4>

<p>We seek to generate statistically significant related queries for
arbitrary input queries. For frequent queries, we may have many
suggestions. But for less frequent queries, maybe there is no
statistically significant related queries. Because of the long tail, the
less frequent queries has a large fraction of the whole queries.</p>

<p>In the same way as we generated the phrase-substitutables, we can break
up the input query into segments, and replace one or several segments by
statistically significant related segments. This will help cover the
infrequent queries.</p>

<ul>
<li><p>generate $m$ candidate whole-query substitutions
$q_i\mapsto q_{i1}, q_{i2}\dots q_{im} $</p></li>
<li><p>segment query into phrases $p_1\dots p_n $</p></li>
<li><p>for each phrase $p_i $</p>

<ul>
<li>  generate $k$ phrase$-$substitutions
$p_i\mapsto p_{i1}, p_{i2}\dots p_{ik} $</li>
<li>  generate new query from a combination of original phrases and
new phrases: $q_i \mapsto p_1\dots p_j^{\prime}\dots p_n$</li>
</ul></li>
</ul>

<p>more information[^1]</p>

<h3 id="Query Rewriting Basing On Click Data">Query Rewriting Basing On Click Data</h3>

<h2 id="query-rewriting-basing-on-click-data">Query Rewriting Basing On Click Data</h2>

<h4 id="Problem Definition">Problem Definition</h4>

<ul>
<li><p>We call the set of engine click set $\mathcal L$, which is
consisted with tuples $\langle q, u, f_{qu} \rangle$. Where $u$
represent the URL and the $q$ represent the query. What’s more,
$f_{qu} $ is the number of times that the users issued query $q$ to
the search engine and clicked on URL $u$. And
$\mathcal Q\  \text{and}\ \mathcal U$ is the set if all
queries and all URLs.
We will consider clock log $\mathcal L$ as a bipartite graph
$\mathcal G = (\mathcal Q,\mathcal U, \mathcal E)$, and
$(q, u)\in E \text{ with weight} f_{qu}$.</p></li>
<li><p>And we define a <em>concepts</em> set
$\mathcal C = {c_{1}, c_{2}, \dots, c_{k} } $. The element in
$\mathcal C$ can be only one concept, such as “shoes” , in more
complex cases we may have different classes in a taxonomy.</p></li>
<li><p>A <em>seed set</em>
$\mathcal S \subseteq\mathcal U\times\mathcal C$, and the
seed set $\mathcal S$ is consists of $\langle u, c\rangle$ pairs.
We can regard this as label the URL with concept $c_{k}$.[^2]</p></li>
</ul>

<h4 id="Absorbing Random Walk Algorithms">Absorbing Random Walk Algorithms</h4>

<p>Intuitively the queries (and URLs) are related to the concept of shoes
because they are connected closely in the graph to the seed set that
represents this concept.</p>

<p>For some query $q \in\mathcal Q$ , we compute the affinity of $q$ to
some seed node $s \in\mathcal S$ as the probability that a random
walk that starts from $q$ ends up at node $s$. The affinity is the
probability that $q$ belongs to concept $c_{i}$ as seed $s$.</p>

<p>Note that in this walk the nodes in the seed set act as <em>absorbing
nodes</em>, that is, sink nodes in the state transition graph from which the
random walk cannot escape. The probability of absorbing nodes are
certainly $1$, which is easy to understand.</p>

<p>And the further away the queries and URLs from seed sets’ URLs, the less
related it should be to the URL’s class. We model this by introducing an
absorbing “null class” node $\omega$ to the graph.</p>

<p>Performing a random walk for every query in the graph is computationally
prohibitive for a large graph. However, there is a simple iterative
algorithm that can compute the class probabilities efficiently. We will
now describe the al- gorithm for the case that we have a single concept
$c$ (that is, $\mathcal C = {c}$), and then show how to generalize to
the case of multiple classes.</p>

<p>Let $\ell_q $ (or $\ell_u $ ) denote the random variable pertaining to
the concept label for query $q$ (or URL $u$). We want to compute
$P(\ell_{q} = c) $Let $\alpha$ be the probability of making a transition
to the null class absorbing node, from any node in the graph. Then we
have that:
$$
P(\ell_q = c) = (1-\alpha) \sum_{u:(q,u)\in E}w_{qu}P(\ell_{u} = c)\tag{1}
$$
where $$w_{qu} = \frac{f_{qu}}{\sum_{u:(q,u)\in E}f_{qu}}$$ we have that
$P(\ell_u = c) = 1 $ if the pair $\langle u, c\rangle$ belongs in the
seed set, and zero otherwise</p>

<p>For all other URLs, the probability $P(\ell_{u} = c) $ is again
recursively computed as:
$$P(\ell_u = c) = (1-\alpha) \sum_{q:(u,q)\in E}w_{uq}P(\ell_{q} = c) \tag{2}$$
where $$w_{uq} = \frac{f_{uq}}{\sum_{q:(u,q)\in E}f_{uq}}$$</p>

<h4 id="algorithm-1-the-arw-for-single-class"><strong>Algorithm 1</strong> The ARW for single class:</h4>

<blockquote>
<p><strong>Require</strong>the seed set $\mathcal S$ for class $c$, the click-graph
$\mathcal G$, the threshold parameter $\gamma$ , the transition
probability $\alpha$ to $\omega$</p>

<p><strong>Ensure</strong> $P (\ell_{q} = c)$, for every query q</p>

<p><strong>for</strong> $u \in \mathcal S$ <strong>do</strong></p>

<blockquote>
<p>$P(\ell_{u}=c)=1$
<strong>end for</strong> </p>
</blockquote>

<p><strong>repeat</strong> </p>

<blockquote>
<p><strong>for all</strong> $q \in \mathcal Q$ <strong>do</strong></p>

<blockquote>
<p>$P(\ell_{q} = c)=(1-\alpha)\sum_{u:(q,u)\in E}\omega_{qu}P(\ell_{u} = c) $</p>

<p><strong>if</strong> $P(\ell_{q} = c) &lt; \gamma$ <strong>then</strong> $P(\ell_{q} = c) = 0 $</p>
</blockquote>

<p><strong>end for</strong></p>

<p><strong>for all</strong> $u \in \mathcal U \backslash S$</p>

<blockquote>
<p>$P(\ell_{u} = c)=(1-\alpha)\sum_{q:(u,q)\in E}\omega_{uq}P(\ell_{q} = c) $</p>

<p><strong>if</strong> $P(\ell_{u} = c) &lt; \gamma$ <strong>then</strong> $P(\ell_{u} = c) = 0$</p>
</blockquote>

<p><strong>end for</strong></p>
</blockquote>

<p><strong>until</strong> convergence</p>

<p>Output $P (\ell_{q} = c)$, for every query $q$ and class $\mathcal Q $</p>
</blockquote>

<p>The algorithm generalizes naturally to the case where there are multiple
concepts, but this process is memory intensive since it requires to
maintain probability vectors for all $k$ classes. Furthermore, the
fraction of the graph that will be explored will increase substantially
even if we prune nodes with low probabilities, since the size of the
seed set may be significantly larger.</p>

<p>This problem can be addressed by considering the con- cepts one at the
time. Let $\mathcal S = \mathcal S_1, \dots\mathcal S_k $be
the partition of the seed set into the k concept. Apllying Algorithms 1
directly for each $\mathcal S_{i}$ is incoreect, because we ignore an
important information: $\mathcal S\backslash\mathcal S_i $ is
null class of $\mathcal S_i $. Apllying with this, we will explore
much smaller fraction of click graphy. we fix the probability of the
nodes in $\mathcal S \backslash\mathcal S_i$ to belong to the
class $c_i$ to zero, thus making them into null absorbing nodes.</p>

<blockquote>
<p><strong>Require</strong>the seed set $\mathcal S$ for class $c$, the click-graph
$\mathcal G$, the threshold parameter $\gamma$ , the transition
probability $\alpha$ to $\omega$</p>
</blockquote>

<h4 id="algorithm-2-the-arw-for-multiple-class"><strong>Algorithm 2</strong> The ARW for multiple class:</h4>

<blockquote>
<p><strong>Require</strong> the seed set $\mathcal S = \{\mathcal S_{1},\dots,\mathcal S_{k}\}$ for concepts $\mathcal C = \{c_{1},\dots,c_{k}\} $, the click-graph $\mathcal G$ the threshold parameter$\gamma $, the transition probability $\alpha$ to $\omega $</p>

<p><strong>Ensure</strong> $P (\ell_{q} = c)$, for every query q</p>

<p><strong>for all</strong> $c_{i} \in \mathcal C$ <strong>do</strong></p>

<blockquote>
<p><strong>for</strong> $u \in \mathcal S \backslash \mathcal S_{i}$</p>

<blockquote>
<p>$P(\ell_{u}=c_{i})=0$</p>
</blockquote>

<p><strong>end for</strong></p>

<p><strong>for</strong> $u \in \mathcal S_{i}$ </p>

<blockquote>
<p>$P(\ell_{u}=c)=1$</p>
</blockquote>

<p><strong>end for</strong> </p>

<p><strong>repeat</strong> </p>

<blockquote>
<p><strong>for all</strong> $q \in \mathcal Q$ <strong>do</strong></p>

<blockquote>
<p>$P(\ell_{q} = c)=(1-\alpha)\sum_{u:(q,u)\in E}\omega_{qu}P(\ell_{u} = c) $</p>

<p><strong>if</strong> $P(\ell_{q} = c) &lt; \gamma$ <strong>then</strong> $P(\ell_{q} = c) = 0$</p>
</blockquote>

<p><strong>end for</strong></p>

<p><strong>for all</strong> $u \in \mathcal U \backslash S$</p>

<blockquote>
<p>$P(\ell_{u} = c)=(1-\alpha)\sum_{q:(u,q)\in E}\omega_{uq}P(\ell_{q} = c) $</p>

<p><strong>if</strong> $P(\ell_{u} = c) &lt; \gamma$ <strong>then</strong> $P(\ell_{u} = c) = 0$</p>
</blockquote>

<p><strong>end for</strong></p>
</blockquote>

<p><strong>until</strong> convergence</p>

<p>Output $P (\ell_{q} = c)$, for every query $q$ and class $\mathcal C $</p>
</blockquote>

<p><strong>end for</strong></p>
</blockquote>

<p>more information here[^3]</p>

<h1 id="remain-to-be-solved">REMAIN TO BE SOLVED</h1>

<p>The problems:</p>

<ol>
<li><p>other algorithms in the paper, and the comparasion between them</p></li>
<li><p>how to bid for AM</p></li>
</ol>

<p>[^1]: Generating Query Substitutions: Jones et al, in Proc of WWW 2006</p>

<p>[^2]: we can also define the seed set as labeled queries or a mix of
    quries and URLs. For simplicity, we will restrict ourselves to the
    case that the seed set consists only of URLs.</p>

<p>[^3]: Using the Wisdom of the Crowds for Keyword Generation: Fuxman et
    al., In proc of WWW 2004</p>

</article>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2016-03-29T17:41:14+08:00">2016</time>. All rights reserved.
        </small>
      </footer>
    </div>

    
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '<USERNAME>'; // required: replace example with your forum shortname
  var disqus_identifier = "/2016/03/02/Sponser-search/";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    
  </body>
</html>
