<!DOCTYPE html>
<html lang="en">

  <head>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    <!--TeX: { equationNumbers: { autoNumber: "AMS"} },-->
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEnvironments: true,
      processEscape: true,
    },
    'HTML-CSS': {
      matchFontHeight: true,
      availableFonts: [],
      webFont: 'TeX'
    }
  });
  </script>

  <script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Young &middot; Machine Learning, Computational Advertising, Algorithms
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="Young" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
        <a href="/" title="Home">Young</a>

        
          &nbsp;&nbsp;&nbsp;
            <small><a href="/about">About</a></small>
        
          &nbsp;&nbsp;&nbsp;
            <small><a href="/Archive">Archive</a></small>
        
        </h3>
      </header>

      <main>
        <div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/2016/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">
        算法笔记一
      </a>
    </h1>

    <time datetime="2016-04-06T00:00:00+08:00" class="post-date">06 Apr 2016</time>

    <blockquote>
<p>本文基于刘汝佳的《算法竞赛入门经典训练指南》第一章，总结阅读第一章的收获</p>
</blockquote>

<h2 id="1">1. 新的算法</h2>

<h3 id="1-1-floyd">1.1 Floyd 判圈算法</h3>

<h4 id=">算法简介</h4>

<p>Floyd判圈算法(Floyd&#39;s Cycle-Finding Algorithm) 在<a href="https://uva.onlinejudge.org/external/115/11549.pdf">计算器谜题</a>中提到。其实对于判圈，我们有一种很直觉的算法:</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//伪代码
</span><span class="n">bool</span> <span class="nf">findCycle</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">List</span> <span class="n">mylist</span><span class="p">;</span>
    <span class="n">hashTable</span> <span class="n">table</span><span class="p">;</span><span class="c1">//哈希表 存储已访问过的节点
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mylist</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="c1">//该节点已经访问过，发现环
</span>        <span class="n">table</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//未发现环
</span><span class="p">}</span>

</code></pre></div>
<p>但是这种算法空间开销较大。</p>

<p>Floyd 判圈算法能够在 $O(n)$ 的时间复杂度和 $O(1)$ 的空间复杂度内，判断是否存在环、环的起点、计算环的长度。</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//伪代码
</span><span class="kt">int</span> <span class="n">cycleLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Node</span> <span class="o">*</span><span class="n">cycleStart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">hasCycle</span><span class="p">;</span>
<span class="c1">//判断环是否存在
</span><span class="n">List</span> <span class="n">mylist</span><span class="p">;</span>
<span class="n">Node</span> <span class="o">*</span><span class="n">n1</span><span class="p">,</span> <span class="o">*</span><span class="n">n2</span><span class="p">;</span>
<span class="n">n1</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mylist</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">hasCycle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//n2已经到达链表末尾，没有环
</span>        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n2</span> <span class="o">==</span> <span class="n">n1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hasCycle</span> <span class="o">=</span>  <span class="nb">true</span><span class="p">;</span><span class="c1">//发现环
</span>        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">hasCycle</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//环的长度
</span>    <span class="k">do</span> <span class="p">{</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">cycleLen</span><span class="o">++</span><span class="p">;</span>      
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">)</span>
<span class="c1">//环起点
</span>    <span class="n">n1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mylist</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n1</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cycleStart</span> <span class="o">=</span> <span class="n">n1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id=">证明</h4>

<p>对于Floyd判圈算法判断环是否存在的证明很容易想到，如果有环，另个速度不同的指针陷入无限循环中一定会相遇，若速度快的指针可以到达末端则不存在环。求环的长度同样很简单。</p>

<p>​Floyd判圈算法求环的起点，<a href="https://www.quora.com/How-does-Floyds-cycle-finding-algorithm-work/answer/Atul-Yadav-2">Quora上的回答</a>非常精彩。</p>

<p><img src="https://github.com/hychn/hychn.github.io/blob/master/img/floyd.png" alt=""></p>

<p>速度较慢的指针走过的距离为: $slowDistance = x+y$ </p>

<p>速度较快的指针走过的距离为: $fastDistance= x+y+z+y $</p>

<p>​ 另外我们知道快指针的速度是慢指针的两倍，所以在相同的时间内，$fastDistance = 2 \times slowDistance$， 所以我们可以推出:
$$
\begin{align}
2(x+y)&amp; = x+y+z+y\\
x &amp;=z
\end{align}
$$
​记住之前指针环绕圈的方向是顺时针（逆时针同理，但是两个指针的方向必须是一样的），把其中一个指针的位置重置到首端（假设为p1），两个指针都以速度$1$移动。因为$x = z$，当p1运动距离$x$，p2运动$z$，两个指针恰好相遇到环的起点。</p>

<h4 id=">使用范围</h4>

<blockquote>
<p>此部分是个人想法，欢迎指正</p>
</blockquote>

<p>​我们最熟悉的判断环的算法是在图论中，同样简单而实用。利用一个<code>marked[]</code>数组，利用深度优先搜索，如果某一节点已经被标记过并且不是该节点的父节点，则发现环。</p>

<p>​我们发现Floyd判圈算法<strong>一般应用在出度为1的情况</strong>，那是否可以应用到复杂的图中呢？在复杂的图中，从一个节点可以到不只一个节点，我们除了保存两个速度不同的指针，最终还必须保存从该节点出发的哪些节点被访问过哪些没有被访问，再使用Floyd算法意义就不大了。所以Floyd算法应该应用在，经过某些规则，有且仅有一个新节点可以从该点到达，这个过程可以是链表的访问，也可以是某种函数计算。</p>

<h3 id="1-2">1.2 中间相遇算法</h3>

<p>​中间相遇算法(meet in themiddle)在<a href="http://acm.tju.edu.cn/toj/vcontest/showp2464_J.html">侏罗纪</a>中用到。中间相遇算法实际上是暴力搜索时的一种小技巧，下面是一道经典例题:</p>

<blockquote>
<p>给出N(N$\leq$ 40)个整数，每个整数的大小为 $10^{12}$ ，找出集合中元素的和小于或者等于S ( S $\leq 10^{18}$)最大的集合（determine the largest sum subset having sum less than or equal S）</p>
</blockquote>

<p>​考虑到集合中元素可以是无序的，虽然$2^{40}$无法暴力求解但是$2^{20}$利用暴力法是可行的。我们将N个整数划分为(S1 S2)两个集合分为前N/2个和后N/2个的集合，分别计算子集和，然后存储在集合X和Y中。将集合Y排序，遍历X中所有的元素，利用二分法在Y集合中找到<code>X[i]+Y[j]&lt;=S</code>的最大元素<code>Y[j]</code>，不断更新<code>ans =max(ans,X[i]+Y[j])</code></p>

<p>​中间相遇算法适用的条件是:</p>

<ul>
<li>对于集合中元素的先后顺序无要求</li>
<li>时间复杂度比较大但是又不那么大</li>
</ul>

<p>详细内容请参考这份<a href="https://www.quora.com/What-is-meet-in-the-middle-algorithm-w-r-t-competitive-programming/answer/Swarn-Avinash-Kumar">Quora回答</a></p>

<h2 id="2">2. 实用的思想</h2>

<h3 id="2-1">2.1 二分思想</h3>

<p>之前我对二分的理解仅限于固定的二分查找，二分查找的核心思想就两个:</p>

<ol>
<li>数组有序</li>
<li>折半查找</li>
</ol>

<p>在刘汝佳的书中，我们看到很多用二分思想的例子，对谁二分？不应该再仅限于数组，如果知道一个下界<code>lowerBound</code>的实数或者整数，还有一个<code>upperBound</code>。那么从<code>lowerBound</code>到<code>upperBound</code>的实数就是天然的递增数组。我们再此基础上进行查找，同样可以压缩空间复杂度。利用二分思想的的例题很多，就不再列举。</p>

<h3 id="2-2">2.2 维护信息</h3>

<p>​这道<a href="https://uva.onlinejudge.org/external/110/p11078.pdf">开放式学分制</a>的例题很有意义，将查找的时间由$O(n^2)$压缩到$O(n)$。之前在USACO上遇到一道题，也是用到了维护信息的思想。平时最习惯的就是<code>for(i=0;i&lt;n;i++)</code>这样直接开始查找，但是有些时候，上一步查找到的元素是某个局部最优解，当我们遇到更优解时才更新它。</p>

<h3 id="2-3">2.3 高维压缩</h3>

<p>​问题求解的思路应该是首先确定一个蠢慢但是正确的算法，然后再进一步优化，只保留最有用的信息，减少复杂度。当遇到高维问题时，我们应该首先从低纬度的问题考虑，尝试能否从低维扩展到高维。如这道<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1696">三维矩阵求和最大的子矩阵</a>，首先考虑到子矩阵一定是连续的，想到一个相似的一维问题，求数组和最大的连续子数组，这个可以再$O(n)$内解决。能否扩展到二维？对于一个二维的子矩阵，可以以x或者y为方向进行压缩（求和），变换成一个等价问题的一维数组。</p>

<p>​当我们找到压缩的方法之后，压缩的时间复杂度成为一个问题，可以利用接下来讲的前缀思想进行预计算。</p>

<h3 id="2-4">2.4 前缀思想</h3>

<p>​前缀思想最初接触到的就是计算序列$A_i,A_{i+1},\dots,A_{j}$的序列和的时候，可以预计算数组B，$B_i = A_0, A_1,\dots,A{i}$ 则序列可以用$B_j-B_{i-1}$在$O(1)$的时间内得到。前缀的思想可以推广到高维，而且曾经在一道二叉树的动态规划题目中也遇到过。当求某些连续的元素时，可以考虑是否利用前缀的思想在有限次运算中得到。</p>

<h2 id="3">3. 总结</h2>

<p>​我之前学习了sedgewick老先生开设的算法课，那时候算法给我的感觉和现在完全是不同的，当时感觉，算法就是这样堂堂正正的、严谨苛刻的，课程中讲的都是十分经典的算法。但是自己刷题还有看刘汝佳这本书，才感觉到世界深深的恶意……算法给我的感觉是天马行空的，现实的问题是如此之多，有很多小巧精致的算法，或者说思想和技巧等待我去学习实践。</p>

<p>​ </p>

<p>​ </p>

<p>​ </p>

  </article>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page3">Older</a>
  
  
    <a class="pagination-item newer" href="/">Newer</a>
  
</div>

      </main>

      <footer class="footer">
        

  There are no comments on this post.

<noscript>Please enable JavaScript to view the comment form powered by <a href="https://commentit.io/">Comm(ent|it)</a></noscript>
<div id="commentit"></div>
<script type="text/javascript">
  /** CONFIGURATION VARIABLES **/
  var commentitUsername = 'hychn';
  var commentitRepo = 'hychn/hychn.github.io';
  var commentitPath = 'page2/index.html';

  /** DON'T EDIT FOLLOWING LINES **/
  (function() {
      var commentit = document.createElement('script');
      commentit.type = 'text/javascript';
      commentit.async = true;
      commentit.src = 'https://commentit.io/static/embed/dist/commentit.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(commentit);
  })();
</script>





        <br />
        <small>
          &copy; <time datetime="2016-12-03T14:03:51+08:00">2016</time>. All rights reserved.
        </small>
      </footer>
    </div>
    
  </body>
</html>
